<!DOCTYPE html>
<html lang="it">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1,user-scalable=no">
<title>Smart Photo Assistant - Il Tuo Occhio Fotografico</title>
<style>
/* STILE GENERALE */
body{font-family:'Segoe UI',Roboto,Helvetica,Arial,sans-serif;margin:0;padding:0;background:#000;color:#fff;height:100vh;display:flex;flex-direction:column;overflow:hidden}
.sr-only{position:absolute;width:1px;height:1px;overflow:hidden;clip:rect(0,0,0,0)}

/* VIDEO */
#cam-container{position:relative;flex-grow:1;width:100%;background:#111;display:flex;justify-content:center;align-items:center}
video{width:100%;height:100%;object-fit:cover;opacity:.6}
canvas{position:absolute;top:0;left:0;width:100%;height:100%;pointer-events:none}

/* Elementi visivi rimossi - solo feedback vocale e screen reader */

/* STATUS VOCALE */
#voice-status{position:absolute;top:10px;right:10px;padding:5px 10px;border-radius:20px;background:rgba(0,0,0,0.7);border:1px solid #555;font-size:0.8rem;z-index:60;display:none}
.listening{border-color:#0f0!important;color:#0f0!important}

/* INTERFACCIA */
#main-interface{height:65vh;width:100%;background:#000;border-top:4px solid #333;position:relative;display:flex;flex-direction:column}
#camera-controls{flex-grow:1;width:100%;display:grid;grid-template-columns:1fr 1fr;grid-auto-rows:min-content;gap:10px;padding:10px;box-sizing:border-box;overflow-y:auto}

/* UTILITÀ */
.full-width{grid-column:1/-1}
.top-bar{display:flex;gap:10px;width:100%}

/* RISULTATO */
#result-screen{height:100%;width:100%;display:flex;flex-direction:column;padding:15px;box-sizing:border-box;background:#111;position:absolute;top:0;left:0;z-index:50}
#result-content{flex-grow:1;overflow-y:auto;margin-bottom:15px;padding:15px;border:1px solid #555;border-radius:8px;background:#000;font-size:1.3rem;line-height:1.5;color:#fff;white-space:pre-wrap}
.result-actions{display:flex;flex-wrap:wrap;gap:10px;flex-shrink:0;min-height:70px}

/* BADGE QUALITÀ */
.quality-badge{display:inline-block;padding:5px 12px;border-radius:20px;font-weight:bold;font-size:0.9rem;margin:5px 5px 5px 0}
.badge-excellent{background:#006400;color:#0f0;border:2px solid #0f0}
.badge-good{background:#8B6914;color:#FFD700;border:2px solid #FFD700}
.badge-acceptable{background:#4B4B00;color:#FFFF00;border:2px solid #FFFF00}
.badge-poor{background:#8B0000;color:#ff5555;border:2px solid #ff5555}

/* GALLERIA FOTO */
#photo-gallery{display:none;flex-direction:column;gap:10px;max-height:400px;overflow-y:auto;margin-top:15px;padding:10px;border:2px solid #555;border-radius:8px;background:#1a1a1a}
.gallery-item{display:flex;align-items:center;gap:10px;padding:10px;background:#000;border:1px solid #444;border-radius:8px}
.gallery-item.selected{border-color:#0f0;background:#002200}
.gallery-thumbnail{width:60px;height:60px;object-fit:cover;border-radius:4px;border:2px solid #555}
.gallery-info{flex-grow:1}
.gallery-controls{display:flex;gap:5px}

/* PULSANTI */
button{border:2px solid #555;border-radius:12px;font-size:1rem;font-weight:bold;text-transform:uppercase;color:#fff;background:#222;cursor:pointer;min-height:60px;display:flex;flex-direction:column;align-items:center;justify-content:center;text-align:center;touch-action:manipulation}
button:active{background:#555;transform:scale(.98)}
.small-btn{flex:1;font-size:.9rem;background:#111;border:1px solid #444;color:#ccc;min-width:80px}

/* COLORI E STATI */
#btn-voice{background:#00008B;border-color:#4169E1} 
#btn-guide{border:2px solid #fff;background:#002200;font-size:1.1rem}
#btn-find{background:#2F4F4F;border-color:#008080;color:#fff}
#btn-custom{background:#4B0082;border-color:#DA70D6}
.active-tool{background:#006400!important;border-color:#0f0!important}
.guiding{background:#8B0000!important;border-color:#f00!important}
.searching{background:#DAA520!important;border-color:#FFD700!important;color:#000!important}

/* STILE SOCIAL / RISULTATO */
.btn-primary-wide{flex:1 1 100%;font-size:1rem;background:#004080;border-color:#88b4ff}
.btn-analyze{flex:1 1 45%;font-size:.9rem;background:#333;border-color:#777}
.btn-danger{flex:1 1 45%;background:#8B0000;border-color:#ff5555}
.btn-social-check{flex:1 1 45%;background:#E1306C!important;border-color:#fff!important;color:#fff!important}
.btn-add-text{flex:1 1 45%;background:#833AB4!important;border-color:#fff!important;color:#fff!important}
.btn-save-best{flex:1 1 45%;background:#006400!important;border-color:#0f0!important;color:#0f0!important}
.btn-view-gallery{flex:1 1 45%;background:#4B0082!important;border-color:#DA70D6!important}

/* OVERLAY AVVIO */
.overlay{position:absolute;top:0;left:0;width:100%;height:100%;background:#000;z-index:100;display:flex;flex-direction:column;justify-content:center;align-items:center}
.hidden{display:none!important}
.loader{border:6px solid #333;border-top:6px solid #D4AF37;border-radius:50%;width:50px;height:50px;animation:spin 1s linear infinite;margin-bottom:20px}
@keyframes spin{0%{transform:rotate(0)}100%{transform:rotate(360deg)}}
input{background:#333;color:#fff;border:1px solid #777}
#download-link{text-align:center;font-size:.9rem;color:#D4AF37;text-decoration:underline;margin-bottom:10px}

/* AREA SCELTA OGGETTI */
#object-choice{display:flex;flex-wrap:wrap;gap:6px;align-items:center;font-size:0.9rem}
#object-choice-label{margin-right:6px}
</style>
</head>
<body>
<div id="sr-announcer" class="sr-only" aria-live="assertive" role="status"></div>

<div id="cam-container">
  <video id="webcam" playsinline muted autoplay></video>
  <canvas id="overlay"></canvas>
  <div id="voice-status">Ascolto in corso...</div>
</div>

<div id="main-interface" class="hidden" aria-hidden="true">
  <div id="camera-controls">
    
    <button class="full-width" id="btn-find" onclick="manualFind()" aria-label="Cerca un oggetto specifico ignorando gli altri.">CERCA OGGETTO</button>

    <div class="full-width" style="height:1px;background:#333;margin:5px 0"></div>

    <button class="full-width" id="btn-guide" onclick="toggleGuidance()" aria-label="Attiva guida scena live con autoscatto intelligente.">GUIDA SCENA LIVE CON AUTO-SCATTO</button>
    
    <div class="top-bar full-width">
       <button class="small-btn" id="btn-shot" onclick="startCountdown()" aria-label="Scatta foto manuale con conto alla rovescia di 5 secondi">SCATTA MANUALE</button>
       <button class="small-btn" onclick="flipCamera()" aria-label="Ruota fotocamera">RUOTA CAMERA</button>
    </div>

    <button id="btn-custom" class="full-width" onclick="askCustomDetail()" aria-label="Scatta e poni una domanda specifica sulla scena">CHIEDI DETTAGLIO</button>

    <button id="btn-describe" class="full-width" onclick="quickDescribeScene()" aria-label="Descrizione rapida di cosa vede la fotocamera">COSA VEDE LA CAMERA</button>

    <div id="object-choice" class="full-width" aria-live="polite"></div>

    <div class="full-width" style="height:1px;background:#333;margin:5px 0"></div>
    <div class="top-bar full-width">
      <button class="small-btn" id="btn-light" onclick="toggleLight()" aria-label="Sonda luce">LUCE</button>
      <button class="small-btn" id="btn-color" onclick="toggleColor()" aria-label="Colore">COLORE</button>
      <button class="small-btn" id="btn-level" onclick="toggleLevel()" aria-label="Livella">LIVELLA</button>
    </div>

    <div class="top-bar full-width" style="margin-top:10px">
      <button class="small-btn" id="btn-voice" onclick="toggleVoiceControl()" aria-label="Comandi vocali opzionali">COMANDI VOCALI</button>
      <button class="small-btn" id="btn-guide-mode" onclick="cycleGuideMode()" aria-label="Cambia livello di dettaglio">GUIDA: STANDARD</button>
      <button class="small-btn" onclick="openSettings()" aria-label="Impostazioni">IMPOSTAZIONI</button>
    </div>
  </div>

  <div id="result-screen" class="hidden" aria-hidden="true" inert role="main">
    <h2 style="margin:0 0 10px;color:#D4AF37;font-size:1.1rem">Foto Acquisita</h2>
    <div id="result-content" tabindex="0">In attesa...</div>
    <a id="download-link" href="#" class="hidden">Scarica foto</a>
    
    <div class="result-actions" id="action-buttons"></div>
    
    <div id="photo-gallery"></div>
  </div>
</div>

<div id="start-screen" class="overlay">
  <h1 style="color:#fff;margin-bottom:20px">Smart Photo Assistant</h1>
  <p style="color:#ccc;text-align:center;max-width:80%;margin-bottom:30px">Il tuo occhio fotografico personale per selfie perfetti e foto pubblicabili</p>
  <button id="btn-start" onclick="startApp()" style="padding:40px;font-size:1.8rem;background:#D4AF37;color:#000;border-radius:15px;width:95%;border:4px solid #fff;font-weight:bold">AVVIA SISTEMA</button>
</div>

<div id="key-screen" class="overlay hidden" aria-hidden="true" inert>
  <h2 style="color:#fff">Chiave Gemini API</h2>
  <input type="text" id="key-input" placeholder="Incolla chiave qui..." style="width:80%;padding:15px;font-size:1.2rem;margin-bottom:20px;border-radius:8px">
  <button onclick="saveKey()" style="padding:15px;background:#fff;color:#000;width:50%;font-weight:bold;border-radius:8px;margin-bottom:10px">SALVA</button>
  <button onclick="closeSettings()" style="padding:15px;background:#333;color:#fff;width:50%;border-radius:8px">CHIUDI</button>
  <p style="width:80%;margin-top:20px;font-size:0.9rem;color:#ddd;text-align:center">
    Le foto vengono analizzate da Gemini AI per valutarne qualità e pubblicabilità.
  </p>
</div>

<script>
let GEMINI_KEY = localStorage.getItem('gemini_key') || "";
const MODEL_NAME = "gemini-2.0-flash-exp"; 
const API_ENDPOINT = "v1beta";

// MODELLI VISIVI
let audioCtx, lightOsc, lightGain;
let objectDetector = null;
let poseLandmarker = null;
let faceLandmarker = null;

let modelsReady = { detector:false, pose:false, face:false };
let guideVerbosity = 'standard';

// SISTEMA QUALITÀ E AUTOSCATTO INTELLIGENTE
let qualityCheckInterval = null;
let currentQualityScore = 0; // 0-100
let currentQualityLevel = 'poor'; // 'poor', 'acceptable', 'good', 'excellent'
let qualityHistory = []; // ultimi 10 frame
let bestQualityInSession = 0;
let lastQualityAnnounce = 0; // per annunci vocali periodici

// Stato autoscatto intelligente
let autoShotTimer = null;
let autoShotMode = null;
let autoShotCountdown = null;
let goodQualityFrames = 0; // conta frame con qualità accettabile
const REQUIRED_GOOD_FRAMES = 15; // ~0.5 secondi a 30fps
const AUTO_SHOT_DELAY = 3; // secondi di countdown dopo rilevamento

// GALLERIA FOTO
let savedPhotos = []; // array di {base64, quality, timestamp, analysis}
let currentPhotoIndex = -1;

let lastGuideType = null;
let lastGuideText = "";
let lastGuideSpeakTime = 0;
let lastGuidancePublishable = false;

let isRunning = false, stream = null;
const tempCanvas = document.createElement('canvas');
let tempCtx = tempCanvas.getContext('2d',{willReadFrequently:true});
let mode = 'idle', lightActive = false, colorActive = false, levelActive = false;
let lastSpeak = 0, centeredFrames = 0, lastGuideMessageTime = 0;
let lastLowLightWarning = 0; 
let lastLightAnnounce = 0; 
let currentFacingMode = 'environment'; 
const video = document.getElementById('webcam'),
      canvas = document.getElementById('overlay'),
      ctx = canvas.getContext('2d');
let lastShotB64 = null;
let targetClass = null;
let hasPerformedSocialCheck = false;

const objectDict = {
  'person': 'Persona', 'cup': 'Tazza', 'chair': 'Sedia', 'bottle': 'Bottiglia', 
  'cell phone': 'Cellulare', 'laptop': 'Computer', 'book': 'Libro', 
  'keyboard': 'Tastiera', 'mouse': 'Mouse', 'remote': 'Telecomando',
  'microwave': 'Microonde', 'oven': 'Forno', 'sink': 'Lavandino',
  'refrigerator': 'Frigorifero', 'clock': 'Orologio', 'vase': 'Vaso',
  'scissors': 'Forbici', 'teddy bear': 'Orsacchiotto', 'hair drier': 'Asciugacapelli',
  'toothbrush': 'Spazzolino', 'backpack': 'Zaino', 'umbrella': 'Ombrello',
  'handbag': 'Borsa', 'tie': 'Cravatta', 'suitcase': 'Valigia',
  'sports ball': 'Palla', 'kite': 'Aquilone', 'baseball bat': 'Mazza da baseball',
  'skateboard': 'Skateboard', 'surfboard': 'Tavola da surf', 'tennis racket': 'Racchetta da tennis',
  'wine glass': 'Bicchiere di vino', 'fork': 'Forchetta', 'knife': 'Coltello', 'spoon': 'Cucchiaio',
  'bowl': 'Ciotola', 'banana': 'Banana', 'apple': 'Mela', 'sandwich': 'Panino',
  'orange': 'Arancia', 'broccoli': 'Broccolo', 'carrot': 'Carota', 'hot dog': 'Hot dog',
  'pizza': 'Pizza', 'donut': 'Ciambella', 'cake': 'Torta',
  'couch': 'Divano', 'potted plant': 'Pianta in vaso', 'bed': 'Letto', 'dining table': 'Tavolo da pranzo',
  'toilet': 'WC', 'tv': 'TV', 'monitor': 'Monitor'
};

function announce(text, urgent=false){
  // Solo annunci per screen reader, NO sintesi vocale
  const el = document.getElementById('sr-announcer');
  el.textContent = '';
  setTimeout(()=>el.textContent = text, 50);
}

// ========== SISTEMA VALUTAZIONE QUALITÀ INTELLIGENTE ==========

function calculateQualityScore(){
  if(!tempCtx || !tempCanvas.width) return 0;
  
  const data = tempCtx.getImageData(0, 0, tempCanvas.width, tempCanvas.height).data;
  let score = 0;
  let factors = [];
  
  // 1. LUMINOSITÀ (0-30 punti)
  let sum = 0;
  for(let i=0; i<data.length; i+=4){
    sum += (data[i] + data[i+1] + data[i+2]) / 3;
  }
  const avgBrightness = sum / (data.length/4);
  
  let lightScore = 0;
  if(avgBrightness >= 80 && avgBrightness <= 180){
    lightScore = 30; // luce ottimale
  } else if(avgBrightness >= 60 && avgBrightness <= 200){
    lightScore = 20; // luce buona
  } else if(avgBrightness >= 40 && avgBrightness <= 220){
    lightScore = 10; // luce accettabile
  }
  score += lightScore;
  factors.push(`Luce: ${lightScore}/30`);
  
  // 2. CONTRASTO (0-20 punti)
  let min = 255, max = 0;
  for(let i=0; i<data.length; i+=4){
    const avg = (data[i] + data[i+1] + data[i+2]) / 3;
    if(avg < min) min = avg;
    if(avg > max) max = avg;
  }
  const contrast = max - min;
  let contrastScore = Math.min(20, Math.floor(contrast / 8));
  score += contrastScore;
  factors.push(`Contrasto: ${contrastScore}/20`);
  
  // 3. NITIDEZZA (0-20 punti) - basata su varianza dei pixel
  let variance = 0;
  for(let i=0; i<data.length; i+=4){
    const pixelBrightness = (data[i] + data[i+1] + data[i+2]) / 3;
    variance += Math.pow(pixelBrightness - avgBrightness, 2);
  }
  variance = Math.sqrt(variance / (data.length/4));
  let sharpnessScore = Math.min(20, Math.floor(variance / 3));
  score += sharpnessScore;
  factors.push(`Nitidezza: ${sharpnessScore}/20`);
  
  // 4. SOGGETTO PRESENTE (0-30 punti) - rilevato da MediaPipe
  let subjectScore = 0;
  if(mode === 'guiding'){
    if(autoShotMode === 'selfie_face' || autoShotMode === 'selfie_full'){
      // Per selfie: premio presenza e posizione del volto/corpo
      if(faceLandmarker && modelsReady.face){
        try{
          const faceResults = faceLandmarker.detectForVideo(video, Date.now());
          if(faceResults.faceLandmarks && faceResults.faceLandmarks.length > 0){
            const face = faceResults.faceLandmarks[0];
            // Calcola posizione del volto
            let sumX = 0, sumY = 0;
            for(const lm of face){
              sumX += lm.x;
              sumY += lm.y;
            }
            const faceX = sumX / face.length;
            const faceY = sumY / face.length;
            
            // Premio centraggio relativo (non perfetto!)
            const centerX = 0.5;
            const centerY = 0.45; // un po' più in alto del centro
            const distX = Math.abs(faceX - centerX);
            const distY = Math.abs(faceY - centerY);
            const totalDist = distX + distY;
            
            // Accetto anche posizioni leggermente decentrate (fino a 0.3 di distanza)
            if(totalDist < 0.15){
              subjectScore = 30; // perfettamente centrato
            } else if(totalDist < 0.25){
              subjectScore = 25; // ben posizionato
            } else if(totalDist < 0.35){
              subjectScore = 20; // accettabile
            } else {
              subjectScore = 10; // presente ma decentrato
            }
          }
        }catch(e){}
      }
      
      // Bonus per corpo visibile
      if(poseLandmarker && modelsReady.pose && autoShotMode === 'selfie_full'){
        try{
          const poseResults = poseLandmarker.detectForVideo(video, Date.now());
          if(poseResults.landmarks && poseResults.landmarks.length > 0){
            subjectScore += 5; // bonus corpo visibile
          }
        }catch(e){}
      }
    } else if(autoShotMode === 'object' && targetClass){
      // Per oggetti: premio presenza dell'oggetto target
      if(objectDetector && modelsReady.detector){
        try{
          const objResults = objectDetector.detectForVideo(video, Date.now());
          if(objResults.detections){
            const target = objResults.detections.find(d => 
              d.categories[0].categoryName === targetClass
            );
            if(target){
              const score = target.categories[0].score;
              if(score > 0.7){
                subjectScore = 30;
              } else if(score > 0.5){
                subjectScore = 20;
              } else {
                subjectScore = 10;
              }
            }
          }
        }catch(e){}
      }
    }
  }
  score += subjectScore;
  factors.push(`Soggetto: ${subjectScore}/30`);
  
  // Normalizza a 0-100
  const finalScore = Math.min(100, Math.round(score));
  
  return {score: finalScore, factors};
}

function updateQualityIndicator(){
  // Solo feedback vocale, nessun display visivo
  if(mode !== 'guiding'){
    return;
  }
  
  const {score, factors} = calculateQualityScore();
  currentQualityScore = score;
  
  // Aggiorna storico
  qualityHistory.push(score);
  if(qualityHistory.length > 10) qualityHistory.shift();
  
  // Calcola media mobile
  const avgScore = qualityHistory.reduce((a,b)=>a+b,0) / qualityHistory.length;
  
  // Determina livello
  let level, text;
  if(avgScore >= 75){
    level = 'excellent';
    text = `Qualità eccellente, punteggio ${Math.round(avgScore)}`;
    goodQualityFrames++;
  } else if(avgScore >= 60){
    level = 'good';
    text = `Qualità buona, punteggio ${Math.round(avgScore)}`;
    goodQualityFrames++;
  } else if(avgScore >= 40){
    level = 'acceptable';
    text = `Qualità accettabile, punteggio ${Math.round(avgScore)}`;
    goodQualityFrames = Math.max(0, goodQualityFrames - 1);
  } else {
    level = 'poor';
    text = `Qualità migliorabile, punteggio ${Math.round(avgScore)}`;
    goodQualityFrames = 0;
  }
  
  currentQualityLevel = level;
  
  // Annuncio vocale periodico della qualità (ogni 5 secondi)
  const now = Date.now();
  if(now - lastQualityAnnounce > 5000){
    announce(text);
    lastQualityAnnounce = now;
  }
  
  // Avvia autoscatto se qualità buona per abbastanza tempo
  if(goodQualityFrames >= REQUIRED_GOOD_FRAMES && !autoShotTimer && !autoShotCountdown){
    triggerAutoShot();
  }
  
  // Aggiorna miglior qualità della sessione
  if(avgScore > bestQualityInSession){
    bestQualityInSession = avgScore;
  }
}

function triggerAutoShot(){
  announce("Ottima inquadratura rilevata! Scatto tra 3 secondi.", true);
  
  let countdown = AUTO_SHOT_DELAY;
  
  // Beep di countdown
  const beep = (freq) => {
    if(!audioCtx) return;
    const osc = audioCtx.createOscillator();
    const gain = audioCtx.createGain();
    osc.connect(gain);
    gain.connect(audioCtx.destination);
    osc.frequency.value = freq;
    gain.gain.value = 0.3;
    osc.start();
    gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.2);
    osc.stop(audioCtx.currentTime + 0.2);
  };
  
  autoShotCountdown = setInterval(() => {
    countdown--;
    if(countdown > 0){
      beep(800);
      announce(countdown.toString(), true);
    } else {
      clearInterval(autoShotCountdown);
      autoShotCountdown = null;
      beep(1200); // beep finale diverso
      captureAndAnalyze();
    }
  }, 1000);
}

function stopAutoShot(){
  if(autoShotCountdown){
    clearInterval(autoShotCountdown);
    autoShotCountdown = null;
  }
  if(autoShotTimer){
    clearTimeout(autoShotTimer);
    autoShotTimer = null;
  }
  goodQualityFrames = 0;
}

async function setupCamera(facingMode='user'){
  try{
    if(stream){
      stream.getTracks().forEach(t=>t.stop());
    }
    const constraints = {
      video:{
        facingMode: facingMode,
        width:{ideal:1920},
        height:{ideal:1080}
      },
      audio:false
    };
    stream = await navigator.mediaDevices.getUserMedia(constraints);
    video.srcObject = stream;
    await video.play();
    
    if(stream.getVideoTracks()[0].getCapabilities){
      const caps = stream.getVideoTracks()[0].getCapabilities();
      if(caps.torch){
        // Supporta flash
      }
    }
    
    announce("Fotocamera attivata.");
  }catch(e){
    console.error("Errore fotocamera",e);
    announce("Impossibile accedere alla fotocamera. Controlla i permessi.");
  }
}

function flipCamera(){
  currentFacingMode = currentFacingMode === 'user' ? 'environment' : 'user';
  setupCamera(currentFacingMode);
  announce(`Camera ${currentFacingMode === 'user' ? 'frontale' : 'posteriore'} attivata.`);
}

function toggleLight(){
  lightActive = !lightActive;
  document.getElementById('btn-light').classList.toggle('active-tool', lightActive);
  if(lightActive){
    announce("Sonda luce attivata.");
    if(!lightOsc){
      lightOsc = audioCtx.createOscillator();
      lightGain = audioCtx.createGain();
      lightOsc.connect(lightGain);
      lightGain.connect(audioCtx.destination);
      lightOsc.type = 'sine';
      lightOsc.frequency.value = 200;
      lightGain.gain.value = 0;
      lightOsc.start();
    }
  }else{
    announce("Sonda luce disattivata.");
    if(lightGain) lightGain.gain.value = 0;
  }
}

function processLight(){
  if(!tempCtx || !lightGain) return;
  const data = tempCtx.getImageData(0,0,tempCanvas.width,tempCanvas.height).data;
  let sum=0;
  for(let i=0;i<data.length;i+=4){
    sum += (data[i]+data[i+1]+data[i+2])/3;
  }
  const avg = sum/(data.length/4);
  const freq = 200 + (avg/255)*800;
  lightOsc.frequency.value = freq;
  lightGain.gain.value = 0.15;
  
  const now = Date.now();
  if(avg < 50 && now - lastLowLightWarning > 5000){
    announce("Attenzione: luce molto bassa.");
    lastLowLightWarning = now;
  }
  if(now - lastLightAnnounce > 3000){
    let desc = avg > 180 ? "molto luminoso" : avg > 120 ? "luminoso" : avg > 80 ? "normale" : avg > 50 ? "poco luminoso" : "molto buio";
    announce(`Livello luce: ${desc}.`);
    lastLightAnnounce = now;
  }
}

function toggleColor(){
  colorActive = !colorActive;
  document.getElementById('btn-color').classList.toggle('active-tool', colorActive);
  announce(colorActive ? "Rilevamento colore attivo." : "Rilevamento colore disattivato.");
}

function processColor(){
  if(!tempCtx) return;
  const w = tempCanvas.width, h = tempCanvas.height;
  const cx = Math.floor(w/2), cy = Math.floor(h/2);
  const data = tempCtx.getImageData(cx-5, cy-5, 10, 10).data;
  let r=0,g=0,b=0,count=0;
  for(let i=0;i<data.length;i+=4){
    r+=data[i]; g+=data[i+1]; b+=data[i+2]; count++;
  }
  r=Math.round(r/count); g=Math.round(g/count); b=Math.round(b/count);
  
  ctx.clearRect(0,0,canvas.width,canvas.height);
  ctx.strokeStyle = `rgb(${r},${g},${b})`;
  ctx.lineWidth = 5;
  ctx.strokeRect(cx-30,cy-30,60,60);
  
  const now = Date.now();
  if(now - lastSpeak > 2000){
    let colorName = getColorName(r,g,b);
    announce(`Colore centrale: ${colorName}.`);
    lastSpeak = now;
  }
}

function getColorName(r,g,b){
  const colors = [
    {name:'rosso',rgb:[255,0,0]}, {name:'verde',rgb:[0,255,0]}, {name:'blu',rgb:[0,0,255]},
    {name:'giallo',rgb:[255,255,0]}, {name:'arancione',rgb:[255,165,0]}, {name:'viola',rgb:[128,0,128]},
    {name:'rosa',rgb:[255,192,203]}, {name:'marrone',rgb:[165,42,42]}, {name:'nero',rgb:[0,0,0]},
    {name:'bianco',rgb:[255,255,255]}, {name:'grigio',rgb:[128,128,128]}
  ];
  let minDist = Infinity, closest = 'sconosciuto';
  for(const c of colors){
    const dist = Math.sqrt(Math.pow(r-c.rgb[0],2)+Math.pow(g-c.rgb[1],2)+Math.pow(b-c.rgb[2],2));
    if(dist < minDist){
      minDist = dist;
      closest = c.name;
    }
  }
  return closest;
}

function toggleLevel(){
  levelActive = !levelActive;
  document.getElementById('btn-level').classList.toggle('active-tool', levelActive);
  announce(levelActive ? "Livella attivata." : "Livella disattivata.");
  
  if(levelActive){
    if(window.DeviceOrientationEvent){
      window.addEventListener('deviceorientation', handleOrientation);
    }else{
      announce("Livella non supportata su questo dispositivo.");
      levelActive = false;
      document.getElementById('btn-level').classList.remove('active-tool');
    }
  }else{
    window.removeEventListener('deviceorientation', handleOrientation);
    ctx.clearRect(0,0,canvas.width,canvas.height);
  }
}

function handleOrientation(e){
  if(!levelActive) return;
  const beta = e.beta || 0;
  const gamma = e.gamma || 0;
  
  ctx.clearRect(0,0,canvas.width,canvas.height);
  const cx = canvas.width/2, cy = canvas.height/2;
  ctx.strokeStyle = '#0f0';
  ctx.lineWidth = 3;
  ctx.beginPath();
  ctx.moveTo(cx-50, cy);
  ctx.lineTo(cx+50, cy);
  ctx.stroke();
  ctx.beginPath();
  ctx.moveTo(cx, cy-50);
  ctx.lineTo(cx, cy+50);
  ctx.stroke();
  
  const offsetX = gamma * 3;
  const offsetY = beta * 3;
  ctx.fillStyle = Math.abs(offsetX)<10 && Math.abs(offsetY)<10 ? '#0f0' : '#f00';
  ctx.beginPath();
  ctx.arc(cx + offsetX, cy + offsetY, 15, 0, Math.PI*2);
  ctx.fill();
  
  if(Math.abs(offsetX)<10 && Math.abs(offsetY)<10){
    const now = Date.now();
    if(now - lastSpeak > 3000){
      announce("Dispositivo in bolla.");
      lastSpeak = now;
    }
  }
}

let recognition = null;
function toggleVoiceControl(){
  if(!('webkitSpeechRecognition' in window || 'SpeechRecognition' in window)){
    announce("Riconoscimento vocale non supportato.");
    return;
  }
  
  if(!recognition){
    const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
    recognition = new SpeechRecognition();
    recognition.lang = 'it-IT';
    recognition.continuous = true;
    recognition.interimResults = false;
    
    recognition.onresult = (e) => {
      const transcript = e.results[e.results.length-1][0].transcript.toLowerCase().trim();
      handleVoiceCommand(transcript);
    };
    
    recognition.onerror = (e) => {
      console.error("Errore riconoscimento vocale", e);
    };
  }
  
  if(document.getElementById('voice-status').style.display === 'none'){
    recognition.start();
    document.getElementById('voice-status').style.display = 'block';
    document.getElementById('btn-voice').classList.add('active-tool');
    announce("Comandi vocali attivati.");
  }else{
    recognition.stop();
    document.getElementById('voice-status').style.display = 'none';
    document.getElementById('btn-voice').classList.remove('active-tool');
    announce("Comandi vocali disattivati.");
  }
}

function handleVoiceCommand(text){
  if(text.includes('scatta') || text.includes('foto')){
    startCountdown();
  }else if(text.includes('guida')){
    toggleGuidance();
  }else if(text.includes('luce')){
    toggleLight();
  }else if(text.includes('colore')){
    toggleColor();
  }else if(text.includes('livella')){
    toggleLevel();
  }else if(text.includes('ruota')){
    flipCamera();
  }else if(text.includes('cerca')){
    manualFind();
  }
}

function cycleGuideMode(){
  const modes = ['breve', 'standard', 'dettagliata'];
  const idx = modes.indexOf(guideVerbosity);
  guideVerbosity = modes[(idx+1) % modes.length];
  updateGuideModeLabel();
  announce(`Modalità guida: ${guideVerbosity}.`);
}

function updateGuideModeLabel(){
  const btn = document.getElementById('btn-guide-mode');
  btn.textContent = `GUIDA: ${guideVerbosity.toUpperCase()}`;
}

function toggleGuidance(){
  if(mode === 'guiding'){
    mode = 'idle';
    stopAutoShot();
    document.getElementById('btn-guide').classList.remove('guiding');
    announce("Guida scena disattivata.");
    qualityHistory = [];
    goodQualityFrames = 0;
  }else{
    if(!GEMINI_KEY){
      announce("Chiave Gemini non configurata. Apri le impostazioni.");
      openSettings();
      return;
    }
    mode = 'guiding';
    autoShotMode = null;
    document.getElementById('btn-guide').classList.add('guiding');
    announce("Guida scena attivata. Scegli il tipo di scatto o attendi il rilevamento automatico.");
    qualityHistory = [];
    goodQualityFrames = 0;
    bestQualityInSession = 0;
  }
}

async function processGuidance(){
  updateQualityIndicator();
  
  // Auto-detect tipo di scatto se non ancora impostato
  if(!autoShotMode){
    let detected = await detectSceneType();
    if(detected){
      autoShotMode = detected;
      const typeNames = {
        'selfie_face': 'selfie del volto',
        'selfie_full': 'selfie figura intera',
        'object': 'oggetto'
      };
      announce(`Rilevato: ${typeNames[autoShotMode]}. Posizionati e attendi l'autoscatto.`);
    }
  }
  
  // Guida vocale periodica
  const now = Date.now();
  if(now - lastGuideMessageTime > 4000){
    provideGuidance();
    lastGuideMessageTime = now;
  }
}

async function detectSceneType(){
  // Rileva se c'è un volto, un corpo, o un oggetto prominente
  let hasFace = false, hasBody = false, hasObject = false;
  
  if(faceLandmarker && modelsReady.face){
    try{
      const faceResults = faceLandmarker.detectForVideo(video, Date.now());
      hasFace = faceResults.faceLandmarks && faceResults.faceLandmarks.length > 0;
    }catch(e){}
  }
  
  if(poseLandmarker && modelsReady.pose){
    try{
      const poseResults = poseLandmarker.detectForVideo(video, Date.now());
      hasBody = poseResults.landmarks && poseResults.landmarks.length > 0;
    }catch(e){}
  }
  
  if(objectDetector && modelsReady.detector){
    try{
      const objResults = objectDetector.detectForVideo(video, Date.now());
      hasObject = objResults.detections && objResults.detections.length > 0;
    }catch(e){}
  }
  
  if(hasFace && hasBody){
    return 'selfie_full';
  }else if(hasFace){
    return 'selfie_face';
  }else if(hasObject){
    return 'object';
  }
  
  return null;
}

function provideGuidance(){
  if(!autoShotMode) return;
  
  let message = "";
  
  if(autoShotMode === 'selfie_face'){
    // Guida per selfie del volto
    if(faceLandmarker && modelsReady.face){
      try{
        const faceResults = faceLandmarker.detectForVideo(video, Date.now());
        if(!faceResults.faceLandmarks || faceResults.faceLandmarks.length === 0){
          message = "Non vedo il tuo volto. Inquadra il viso.";
        }else{
          const face = faceResults.faceLandmarks[0];
          let sumX = 0, sumY = 0;
          for(const lm of face){
            sumX += lm.x;
            sumY += lm.y;
          }
          const faceX = sumX / face.length;
          const faceY = sumY / face.length;
          
          if(faceX < 0.4){
            message = "Muoviti un po' a destra.";
          }else if(faceX > 0.6){
            message = "Muoviti un po' a sinistra.";
          }else if(faceY < 0.35){
            message = "Abbassa leggermente il telefono.";
          }else if(faceY > 0.55){
            message = "Alza leggermente il telefono.";
          }else{
            message = "Posizione buona! Mantieni così.";
          }
        }
      }catch(e){}
    }
  }else if(autoShotMode === 'selfie_full'){
    // Guida per selfie figura intera
    if(poseLandmarker && modelsReady.pose){
      try{
        const poseResults = poseLandmarker.detectForVideo(video, Date.now());
        if(!poseResults.landmarks || poseResults.landmarks.length === 0){
          message = "Non vedo la tua figura. Allontanati un po'.";
        }else{
          message = "Buona posizione! Mantieni la posa.";
        }
      }catch(e){}
    }
  }else if(autoShotMode === 'object'){
    // Guida per oggetto
    if(objectDetector && modelsReady.detector && targetClass){
      try{
        const objResults = objectDetector.detectForVideo(video, Date.now());
        const target = objResults.detections.find(d => 
          d.categories[0].categoryName === targetClass
        );
        if(!target){
          message = "Oggetto non visibile. Inquadralo meglio.";
        }else{
          const box = target.boundingBox;
          const centerX = box.originX + box.width / 2;
          const centerY = box.originY + box.height / 2;
          
          if(centerX < 0.4){
            message = "Sposta la camera a sinistra.";
          }else if(centerX > 0.6){
            message = "Sposta la camera a destra.";
          }else{
            message = "Oggetto ben inquadrato.";
          }
        }
      }catch(e){}
    }
  }
  
  // Aggiungi info sulla qualità
  if(currentQualityLevel === 'excellent'){
    message += " Qualità eccellente!";
  }else if(currentQualityLevel === 'good'){
    message += " Qualità buona.";
  }else if(currentQualityLevel === 'poor'){
    message += " Luce insufficiente.";
  }
  
  if(message && message !== lastGuideText){
    announce(message);
    lastGuideText = message;
  }
}

function manualFind(){
  const obj = prompt("Che oggetto vuoi cercare? (es: tazza, libro, sedia)");
  if(!obj) return;
  selectObjectFromChoice(obj, obj);
}

function selectObjectFromChoice(engName, itaName){
  targetClass = engName;
  autoShotMode = 'object';
  announce(`Cerco: ${itaName}. Attendi l'autoscatto quando l'oggetto è ben inquadrato.`);
  
  // Pulisci area scelta
  document.getElementById('object-choice').innerHTML = '';
  
  if(mode !== 'guiding'){
    toggleGuidance();
  }
}

async function quickDescribeScene(){
  announce("Analizzando la scena...");
  
  let parts = [];
  const choiceDiv = document.getElementById('object-choice');
  choiceDiv.innerHTML = '';
  
  try{
    let personSeen = false;
    let options = [];
    
    if(faceLandmarker && modelsReady.face){
      try{
        const faceResults = faceLandmarker.detectForVideo(video, Date.now());
        if(faceResults.faceLandmarks && faceResults.faceLandmarks.length > 0){
          parts.push("Vedo il tuo volto.");
          personSeen = true;
        }
      }catch(e){}
    }
    
    if(objectDetector && modelsReady.detector){
      try{
        const objResults = objectDetector.detectForVideo(video, Date.now());
        if(objResults.detections && objResults.detections.length > 0){
          const seen = new Set();
          const labels = [];
          
          for(const det of objResults.detections){
            if(det.categories[0].score < 0.5) continue;
            const className = det.categories[0].categoryName;
            if(seen.has(className)) continue;
            seen.add(className);
            
            const name = objectDict[className] || className;
            labels.push(name);
            
            let foundEng = null;
            for(const [eng, ita] of Object.entries(objectDict)){
              if(ita === name || eng === name){
                foundEng = eng;
                break;
              }
            }
            if(foundEng){
              options.push({eng:foundEng, ita:name});
            }
          }
          
          if(labels.length){
            const list = labels.join(", ");
            if(personSeen){
              parts.push("In più vedo: " + list + ".");
            }else{
              parts.push("Vedo: " + list + ".");
            }
          }
        }
      }catch(e){}
    }
    
    if(options.length){
      const labelEl = document.createElement('div');
      labelEl.id = 'object-choice-label';
      labelEl.textContent = "Scegli cosa fotografare:";
      choiceDiv.appendChild(labelEl);
      
      for(const opt of options){
        const btn = document.createElement('button');
        btn.type = 'button';
        btn.className = 'small-btn';
        btn.textContent = opt.ita.toUpperCase();
        btn.onclick = ()=>selectObjectFromChoice(opt.eng, opt.ita);
        choiceDiv.appendChild(btn);
      }
      
      parts.push("Puoi scegliere l'oggetto da fotografare con i pulsanti sotto.");
    }
    
  }catch(e){
    console.error("Errore quickDescribeScene", e);
  }
  
  if(!parts.length){
    announce("Al momento non riconosco persone o oggetti chiari.");
  }else{
    announce(parts.join(" "));
  }
}

function startCountdown(){
  announce("Scatto tra 5 secondi.");
  let count = 5;
  const interval = setInterval(() => {
    count--;
    if(count > 0){
      announce(count.toString());
    }else{
      clearInterval(interval);
      captureAndAnalyze();
    }
  }, 1000);
}

async function captureAndAnalyze(){
  if(!video.videoWidth) return;
  
  const captureCanvas = document.createElement('canvas');
  captureCanvas.width = video.videoWidth;
  captureCanvas.height = video.videoHeight;
  const captureCtx = captureCanvas.getContext('2d');
  captureCtx.drawImage(video, 0, 0);
  
  const base64 = captureCanvas.toDataURL('image/jpeg', 0.92);
  lastShotB64 = base64;
  
  announce("Foto scattata. Analizzo la qualità...");
  
  // Analisi qualità con AI
  await analyzePhotoQuality(base64);
}

async function analyzePhotoQuality(base64Image){
  if(!GEMINI_KEY){
    announce("Chiave Gemini non configurata.");
    return;
  }
  
  showResult("Analisi in corso...");
  
  try{
    const imageData = base64Image.split(',')[1];
    
    const prompt = `Analizza questa foto e valutane la QUALITÀ per la pubblicazione sui social media.

Considera questi criteri:
1. LUMINOSITÀ: La luce è buona? Troppo scura o sovraesposta?
2. NITIDEZZA: La foto è nitida o sfocata?
3. COMPOSIZIONE: Il soggetto è ben inquadrato? La regola dei terzi è rispettata?
4. SOGGETTO: Il soggetto principale è chiaro? È in posizione naturale?
5. SFONDO: Lo sfondo è pulito o distrae dal soggetto?
6. ESPRESSIONE (per selfie): L'espressione è naturale e piacevole?

Fornisci:
1. Un PUNTEGGIO complessivo da 0 a 100
2. Un GIUDIZIO: ECCELLENTE (90-100), BUONA (70-89), ACCETTABILE (50-69), SCADENTE (0-49)
3. PUNTI DI FORZA (max 3)
4. SUGGERIMENTI per migliorare (max 3)
5. PUBBLICABILE: SÌ o NO (considera se la foto è adatta per Instagram/Facebook)

Formato risposta:
PUNTEGGIO: [numero]
GIUDIZIO: [giudizio]
PUBBLICABILE: [SÌ/NO]

PUNTI DI FORZA:
- [punto 1]
- [punto 2]
- [punto 3]

SUGGERIMENTI:
- [suggerimento 1]
- [suggerimento 2]
- [suggerimento 3]`;
    
    const response = await fetch(`https://generativelanguage.googleapis.com/${API_ENDPOINT}/models/${MODEL_NAME}:generateContent?key=${GEMINI_KEY}`, {
      method: 'POST',
      headers: {'Content-Type': 'application/json'},
      body: JSON.stringify({
        contents: [{
          parts: [
            {text: prompt},
            {inline_data: {mime_type: 'image/jpeg', data: imageData}}
          ]
        }]
      })
    });
    
    const data = await response.json();
    if(data.candidates && data.candidates[0].content){
      const analysis = data.candidates[0].content.parts[0].text;
      
      // Estrai punteggio e pubblicabilità
      const scoreMatch = analysis.match(/PUNTEGGIO:\s*(\d+)/i);
      const pubMatch = analysis.match(/PUBBLICABILE:\s*(SÌ|SI|NO)/i);
      const score = scoreMatch ? parseInt(scoreMatch[1]) : 50;
      const publishable = pubMatch ? pubMatch[1].toUpperCase().includes('S') : false;
      
      // Salva foto in galleria
      const photoData = {
        base64: lastShotB64,
        quality: score,
        publishable: publishable,
        timestamp: Date.now(),
        analysis: analysis
      };
      savedPhotos.push(photoData);
      currentPhotoIndex = savedPhotos.length - 1;
      
      // Mostra risultato con badge qualità
      let badgeClass = score >= 90 ? 'badge-excellent' : 
                       score >= 70 ? 'badge-good' : 
                       score >= 50 ? 'badge-acceptable' : 'badge-poor';
      
      let badgeText = score >= 90 ? 'ECCELLENTE' : 
                      score >= 70 ? 'BUONA' : 
                      score >= 50 ? 'ACCETTABILE' : 'MIGLIORABILE';
      
      const badge = `<span class="quality-badge ${badgeClass}">Qualità: ${badgeText} (${score}/100)</span>`;
      const pubBadge = publishable ? 
        '<span class="quality-badge badge-excellent">✓ PUBBLICABILE</span>' : 
        '<span class="quality-badge badge-poor">✗ NON PUBBLICABILE</span>';
      
      showResult(`${badge} ${pubBadge}\n\n${analysis}`);
      
      // Annuncio vocale
      announce(`Foto analizzata. Qualità ${badgeText}, punteggio ${score} su 100. ${publishable ? 'La foto è pubblicabile.' : 'Sconsiglio di pubblicare questa foto.'}`);
      
      // Aggiungi pulsante per salvare se buona
      if(score >= 70){
        addActionButton("SALVA NELLE MIGLIORI", () => saveAsBest(), "btn-save-best");
      }
      
    }else{
      showResult("Errore nell'analisi AI.");
      announce("Errore nell'analisi della foto.");
    }
    
  }catch(e){
    console.error("Errore analisi", e);
    showResult("Errore di connessione: " + e.message);
    announce("Errore durante l'analisi della foto.");
  }
}

function saveAsBest(){
  if(currentPhotoIndex >= 0){
    const photo = savedPhotos[currentPhotoIndex];
    photo.marked = true;
    announce("Foto salvata nelle migliori!");
  }
}

function askCustomDetail(){
  const question = prompt("Cosa vuoi sapere sulla scena?");
  if(!question) return;
  
  announce("Scatto e analizzo...");
  
  setTimeout(async () => {
    await captureAndAnalyze();
    
    // Poi fai domanda custom su quella foto
    if(!GEMINI_KEY || !lastShotB64){
      announce("Impossibile analizzare.");
      return;
    }
    
    showResult("Analisi in corso...");
    
    try{
      const imageData = lastShotB64.split(',')[1];
      const response = await fetch(`https://generativelanguage.googleapis.com/${API_ENDPOINT}/models/${MODEL_NAME}:generateContent?key=${GEMINI_KEY}`, {
        method: 'POST',
        headers: {'Content-Type': 'application/json'},
        body: JSON.stringify({
          contents: [{
            parts: [
              {text: question},
              {inline_data: {mime_type: 'image/jpeg', data: imageData}}
            ]
          }]
        })
      });
      
      const data = await response.json();
      if(data.candidates && data.candidates[0].content){
        const answer = data.candidates[0].content.parts[0].text;
        showResult(`Domanda: ${question}\n\nRisposta:\n${answer}`);
        announce("Risposta ricevuta.");
      }else{
        showResult("Nessuna risposta ricevuta.");
      }
    }catch(e){
      showResult("Errore: " + e.message);
    }
  }, 500);
}

function showResult(text){
  document.getElementById('result-content').textContent = text;
  document.getElementById('result-screen').classList.remove('hidden');
  document.getElementById('result-screen').removeAttribute('aria-hidden');
  document.getElementById('result-screen').removeAttribute('inert');
  document.getElementById('download-link').href = lastShotB64 || '#';
  document.getElementById('download-link').download = 'foto_' + Date.now() + '.jpg';
  document.getElementById('download-link').classList.toggle('hidden', !lastShotB64);
  
  setupResultActions();
}

function setupResultActions(){
  const container = document.getElementById('action-buttons');
  container.innerHTML = '';
  
  addActionButton("NUOVA FOTO", () => {
    document.getElementById('result-screen').classList.add('hidden');
    document.getElementById('result-screen').setAttribute('aria-hidden','true');
    document.getElementById('result-screen').setAttribute('inert','');
    announce("Pronta per nuova foto.");
  }, "btn-primary-wide");
  
  if(lastShotB64){
    addActionButton("ANALISI SOCIAL", () => performSocialCheck(), "btn-social-check");
    addActionButton("AGGIUNGI TESTO", () => addTextToImage(), "btn-add-text");
  }
  
  if(savedPhotos.length > 0){
    addActionButton("VEDI GALLERIA", () => showGallery(), "btn-view-gallery");
  }
}

function addActionButton(text, onClick, className){
  const container = document.getElementById('action-buttons');
  const btn = document.createElement('button');
  btn.textContent = text;
  btn.className = className;
  btn.onclick = onClick;
  container.appendChild(btn);
}

async function performSocialCheck(){
  if(!GEMINI_KEY || !lastShotB64){
    announce("Chiave Gemini non configurata o nessuna foto.");
    return;
  }
  
  showResult("Controllo compatibilità social...");
  announce("Analizzo compatibilità con i social media.");
  
  try{
    const imageData = lastShotB64.split(',')[1];
    const response = await fetch(`https://generativelanguage.googleapis.com/${API_ENDPOINT}/models/${MODEL_NAME}:generateContent?key=${GEMINI_KEY}`, {
      method: 'POST',
      headers: {'Content-Type': 'application/json'},
      body: JSON.stringify({
        contents: [{
          parts: [
            {text: "Analizza questa foto per la pubblicazione sui social media (Instagram, Facebook, Twitter). Considera: qualità, appropriatezza del contenuto, appeal visivo, conformità alle linee guida. Fornisci una valutazione dettagliata e suggerimenti."},
            {inline_data: {mime_type: 'image/jpeg', data: imageData}}
          ]
        }]
      })
    });
    
    const data = await response.json();
    if(data.candidates && data.candidates[0].content){
      const result = data.candidates[0].content.parts[0].text;
      showResult("ANALISI SOCIAL MEDIA:\n\n" + result);
      announce("Analisi social completata.");
    }
  }catch(e){
    showResult("Errore: " + e.message);
  }
}

function addTextToImage(){
  const text = prompt("Che testo vuoi aggiungere alla foto?");
  if(!text || !lastShotB64) return;
  
  const img = new Image();
  img.onload = () => {
    const canvas = document.createElement('canvas');
    canvas.width = img.width;
    canvas.height = img.height;
    const ctx = canvas.getContext('2d');
    
    ctx.drawImage(img, 0, 0);
    
    const fontSize = Math.floor(img.width / 15);
    ctx.font = `bold ${fontSize}px Arial`;
    ctx.fillStyle = '#fff';
    ctx.strokeStyle = '#000';
    ctx.lineWidth = 3;
    ctx.textAlign = 'center';
    ctx.textBaseline = 'bottom';
    
    const x = img.width / 2;
    const y = img.height - 30;
    
    ctx.strokeText(text, x, y);
    ctx.fillText(text, x, y);
    
    lastShotB64 = canvas.toDataURL('image/jpeg', 0.92);
    document.getElementById('download-link').href = lastShotB64;
    
    announce("Testo aggiunto alla foto.");
  };
  img.src = lastShotB64;
}

function showGallery(){
  const gallery = document.getElementById('photo-gallery');
  gallery.innerHTML = '<h3 style="margin:0 0 10px;color:#D4AF37">Galleria Foto</h3>';
  gallery.style.display = 'flex';
  
  if(savedPhotos.length === 0){
    gallery.innerHTML += '<p>Nessuna foto salvata.</p>';
    return;
  }
  
  savedPhotos.forEach((photo, index) => {
    const item = document.createElement('div');
    item.className = 'gallery-item';
    if(photo.marked) item.classList.add('selected');
    
    const thumb = document.createElement('img');
    thumb.src = photo.base64;
    thumb.className = 'gallery-thumbnail';
    thumb.alt = `Foto ${index + 1}`;
    
    const info = document.createElement('div');
    info.className = 'gallery-info';
    info.innerHTML = `
      <div>Foto ${index + 1}</div>
      <div style="font-size:0.9rem;color:#ccc">Qualità: ${photo.quality}/100</div>
      <div style="font-size:0.9rem;color:${photo.publishable ? '#0f0' : '#f00'}">
        ${photo.publishable ? '✓ Pubblicabile' : '✗ Non pubblicabile'}
      </div>
      ${photo.marked ? '<div style="font-size:0.9rem;color:#FFD700">★ Migliore</div>' : ''}
    `;
    
    const controls = document.createElement('div');
    controls.className = 'gallery-controls';
    
    const viewBtn = document.createElement('button');
    viewBtn.textContent = 'Vedi';
    viewBtn.className = 'small-btn';
    viewBtn.onclick = () => {
      lastShotB64 = photo.base64;
      currentPhotoIndex = index;
      showResult(photo.analysis || "Dettagli non disponibili");
    };
    
    const markBtn = document.createElement('button');
    markBtn.textContent = photo.marked ? '★' : '☆';
    markBtn.className = 'small-btn';
    markBtn.onclick = () => {
      photo.marked = !photo.marked;
      showGallery();
      announce(photo.marked ? "Foto marcata come migliore" : "Marca rimossa");
    };
    
    controls.appendChild(viewBtn);
    controls.appendChild(markBtn);
    
    item.appendChild(thumb);
    item.appendChild(info);
    item.appendChild(controls);
    
    gallery.appendChild(item);
  });
  
  const closeBtn = document.createElement('button');
  closeBtn.textContent = 'CHIUDI GALLERIA';
  closeBtn.className = 'btn-primary-wide';
  closeBtn.onclick = () => {
    gallery.style.display = 'none';
  };
  gallery.appendChild(closeBtn);
  
  announce(`Galleria aperta. ${savedPhotos.length} foto salvate.`);
}

async function startApp(){
  document.getElementById('main-interface').classList.remove('hidden');
  document.getElementById('main-interface').removeAttribute('aria-hidden');
  document.getElementById('start-screen').classList.add('hidden');
  document.getElementById('start-screen').setAttribute('aria-hidden','true');
  document.getElementById('btn-shot').focus();
  updateGuideModeLabel();
  announce("Smart Photo Assistant avviato.");
  audioCtx = new (window.AudioContext||window.webkitAudioContext)();
  await setupCamera('user'); // Inizio con camera frontale per selfie
  
  try{
    const {
      ObjectDetector,
      PoseLandmarker,
      FaceLandmarker,
      FilesetResolver
    } = await import("https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/vision_bundle.js");
    
    const vision = await FilesetResolver.forVisionTasks("https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm");
    
    try{
      objectDetector = await ObjectDetector.createFromOptions(vision,{
        baseOptions:{
          modelAssetPath:"https://storage.googleapis.com/mediapipe-models/object_detector/efficientdet_lite0/float16/1/efficientdet_lite0.tflite",
          delegate:"GPU"
        },
        scoreThreshold:0.3,
        runningMode:"VIDEO"
      });
      modelsReady.detector = true;
    }catch(e){
      console.error("ObjectDetector error", e);
    }
    
    try{
      poseLandmarker = await PoseLandmarker.createFromOptions(vision,{
        baseOptions:{
          modelAssetPath:"https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task",
          delegate:"GPU"
        },
        runningMode:"VIDEO",
        numPoses:1
      });
      modelsReady.pose = true;
    }catch(e){
      console.error("PoseLandmarker error", e);
    }
    
    try{
      faceLandmarker = await FaceLandmarker.createFromOptions(vision,{
        baseOptions:{
          modelAssetPath:"https://storage.googleapis.com/mediapipe-models/face_landmarker/face_landmarker/float16/1/face_landmarker.task",
          delegate:"GPU"
        },
        runningMode:"VIDEO",
        numFaces:1
      });
      modelsReady.face = true;
    }catch(e){
      console.error("FaceLandmarker error", e);
    }
    
    if(modelsReady.face && modelsReady.pose){
      announce("Riconoscimento volto e corpo attivo. Pronto per selfie intelligenti.");
    }else if(modelsReady.detector){
      announce("Riconoscimento oggetti attivo.");
    }
    
  }catch(e){
    console.error("Errore import MediaPipe", e);
    announce("Modelli di riconoscimento limitati. Funzioni base disponibili.");
  }
  
  isRunning = true;
  loop();
}

function loop(){
  if(!isRunning){
    requestAnimationFrame(loop);
    return;
  }
  if(video.readyState===4 && tempCtx){
    if(tempCanvas.width!==video.videoWidth){
      tempCanvas.width=video.videoWidth;
      tempCanvas.height=video.videoHeight;
      canvas.width=video.videoWidth;
      canvas.height=video.videoHeight;
    }
    tempCtx.drawImage(video,0,0,tempCanvas.width,tempCanvas.height);
    if(lightActive)processLight();
    if(colorActive)processColor();
    if(mode==='guiding')processGuidance();
  }
  requestAnimationFrame(loop);
}

window.openSettings=()=>{
  const ks = document.getElementById('key-screen');
  ks.classList.remove('hidden');
  ks.removeAttribute('aria-hidden');
  ks.removeAttribute('inert');
  document.getElementById('key-input').value = GEMINI_KEY;
};

window.closeSettings=()=>{
  const ks = document.getElementById('key-screen');
  ks.classList.add('hidden');
  ks.setAttribute('aria-hidden','true');
  ks.setAttribute('inert','');
};

window.saveKey=()=>{
  GEMINI_KEY=document.getElementById('key-input').value.trim();
  localStorage.setItem('gemini_key',GEMINI_KEY);
  closeSettings();
  announce("Chiave Gemini salvata.");
};
</script>
</body>
</html>