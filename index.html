<!DOCTYPE html>
<html lang="it">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1,user-scalable=no">
<title>Visione AI Fusion - Selfie Friendly AutoShot</title>
<style>
/* STILE GENERALE */
body{font-family:'Segoe UI',Roboto,Helvetica,Arial,sans-serif;margin:0;padding:0;background:#000;color:#fff;height:100vh;display:flex;flex-direction:column;overflow:hidden}
.sr-only{position:absolute;width:1px;height:1px;overflow:hidden;clip:rect(0,0,0,0)}

/* VIDEO */
#cam-container{position:relative;flex-grow:1;width:100%;background:#111;display:flex;justify-content:center;align-items:center}
video{width:100%;height:100%;object-fit:cover;opacity:.6}
canvas{position:absolute;top:0;left:0;width:100%;height:100%;pointer-events:none}

/* STATUS VOCALE */
#voice-status{position:absolute;top:10px;right:10px;padding:5px 10px;border-radius:20px;background:rgba(0,0,0,0.7);border:1px solid #555;font-size:0.8rem;z-index:60;display:none}
.listening{border-color:#0f0!important;color:#0f0!important}

/* INTERFACCIA */
#main-interface{height:65vh;width:100%;background:#000;border-top:4px solid #333;position:relative;display:flex;flex-direction:column}
#camera-controls{flex-grow:1;width:100%;display:grid;grid-template-columns:1fr 1fr;grid-auto-rows:min-content;gap:10px;padding:10px;box-sizing:border-box;overflow-y:auto}

/* UTILIT√Ä */
.full-width{grid-column:1/-1}
.top-bar{display:flex;gap:10px;width:100%}

/* RISULTATO */
#result-screen{height:100%;width:100%;display:flex;flex-direction:column;padding:15px;box-sizing:border-box;background:#111;position:absolute;top:0;left:0;z-index:50}
#result-content{flex-grow:1;overflow-y:auto;margin-bottom:15px;padding:15px;border:1px solid #555;border-radius:8px;background:#000;font-size:1.3rem;line-height:1.5;color:#fff;white-space:pre-wrap}
.result-actions{display:flex;flex-wrap:wrap;gap:10px;flex-shrink:0;min-height:70px}

/* PULSANTI */
button{border:2px solid #555;border-radius:12px;font-size:1rem;font-weight:bold;text-transform:uppercase;color:#fff;background:#222;cursor:pointer;min-height:60px;display:flex;flex-direction:column;align-items:center;justify-content:center;text-align:center;touch-action:manipulation}
button:active{background:#555;transform:scale(.98)}
.small-btn{flex:1;font-size:.9rem;background:#111;border:1px solid #444;color:#ccc;min-width:80px}

/* COLORI E STATI */
#btn-voice{background:#00008B;border-color:#4169E1} 
#btn-guide{border:2px solid #fff;background:#002200;font-size:1.1rem}
#btn-find{background:#2F4F4F;border-color:#008080;color:#fff}
#btn-custom{background:#4B0082;border-color:#DA70D6}
.active-tool{background:#006400!important;border-color:#0f0!important}
.guiding{background:#8B0000!important;border-color:#f00!important}
.searching{background:#DAA520!important;border-color:#FFD700!important;color:#000!important}
.active-discrete{border-color:#f00;color:#f00}

/* STILE SOCIAL / RISULTATO */
.btn-primary-wide{flex:1 1 100%;font-size:1rem;background:#004080;border-color:#88b4ff}
.btn-analyze{flex:1 1 45%;font-size:.9rem;background:#333;border-color:#777}
.btn-danger{flex:1 1 45%;background:#8B0000;border-color:#ff5555}
.btn-social-check{flex:1 1 45%;background:#E1306C!important;border-color:#fff!important;color:#fff!important}
.btn-add-text{flex:1 1 45%;background:#833AB4!important;border-color:#fff!important;color:#fff!important}

/* OVERLAY AVVIO */
.overlay{position:absolute;top:0;left:0;width:100%;height:100%;background:#000;z-index:100;display:flex;flex-direction:column;justify-content:center;align-items:center}
.hidden{display:none!important}
.loader{border:6px solid #333;border-top:6px solid #D4AF37;border-radius:50%;width:50px;height:50px;animation:spin 1s linear infinite;margin-bottom:20px}
@keyframes spin{0%{transform:rotate(0)}100%{transform:rotate(360deg)}}
input{background:#333;color:#fff;border:1px solid #777}
#download-link{text-align:center;font-size:.9rem;color:#D4AF37;text-decoration:underline;margin-bottom:10px}

/* AREA SCELTA OGGETTI */
#object-choice{display:flex;flex-wrap:wrap;gap:6px;align-items:center;font-size:0.9rem}
#object-choice-label{margin-right:6px}
</style>
</head>
<body>
<div id="sr-announcer" class="sr-only" aria-live="assertive" role="status"></div>

<div id="cam-container">
  <video id="webcam" playsinline muted autoplay></video>
  <canvas id="overlay"></canvas>
  <div id="voice-status">üé§ Ascolto...</div>
</div>

<div id="main-interface" class="hidden" aria-hidden="true">
  <div id="camera-controls">
    
    <button class="full-width" id="btn-find" onclick="manualFind()" aria-label="Cerca un oggetto specifico ignorando gli altri.">üîç CERCA OGGETTO (MANUALE)</button>

    <div class="full-width" style="height:1px;background:#333;margin:5px 0"></div>

    <button class="full-width" id="btn-guide" onclick="toggleGuidance()" aria-label="Attiva guida scena live con autoscatto.">GUIDA SCENA LIVE</button>
    
    <div class="top-bar full-width">
       <button class="small-btn" id="btn-shot" onclick="startCountdown()" aria-label="Scatta foto manuale con conto alla rovescia di 5 secondi">SCATTA (5s)</button>
       <button class="small-btn" onclick="flipCamera()" aria-label="Ruota fotocamera">RUOTA CAMERA</button>
    </div>

    <button id="btn-custom" class="full-width" onclick="askCustomDetail()" aria-label="Scatta e poni una domanda specifica sulla scena">CHIEDI DETTAGLIO</button>

    <!-- Descrizione rapida di cosa vede la camera -->
    <button id="btn-describe" class="full-width" onclick="quickDescribeScene()" aria-label="Descrizione rapida di cosa vede la fotocamera, persone o oggetti">COSA VEDE LA CAMERA</button>

    <!-- SCELTA OGGETTO CON PULSANTI (NESSUNA VOCE, NESSUNA SCRITTURA) -->
    <div id="object-choice" class="full-width" aria-live="polite"></div>

    <div class="full-width" style="height:1px;background:#333;margin:5px 0"></div>
    <div class="top-bar full-width">
      <button class="small-btn" id="btn-light" onclick="toggleLight()" aria-label="Sonda luce">LUCE</button>
      <button class="small-btn" id="btn-color" onclick="toggleColor()" aria-label="Colore">COLORE</button>
      <button class="small-btn" id="btn-level" onclick="toggleLevel()" aria-label="Livella">LIVELLA</button>
    </div>

    <div class="top-bar full-width" style="margin-top:10px">
      <button class="small-btn" id="btn-discrete" onclick="toggleDiscrete()" aria-label="Modo discreto senza voce">MODO DISCRETO</button>
      <button class="small-btn" id="btn-voice" onclick="toggleVoiceControl()" aria-label="Comandi vocali opzionali">COMANDI VOCALI (OPZ)</button>
      <button class="small-btn" id="btn-guide-mode" onclick="cycleGuideMode()" aria-label="Cambia livello di dettaglio della guida">GUIDA: STANDARD</button>
      <button class="small-btn" onclick="openSettings()" aria-label="Impostazioni e chiave Gemini">IMPOSTAZIONI</button>
    </div>
  </div>

  <div id="result-screen" class="hidden" aria-hidden="true" inert role="main">
    <h2 style="margin:0 0 10px;color:#D4AF37;font-size:1.1rem">Foto acquisita</h2>
    <div id="result-content" tabindex="0">In attesa...</div>
    <a id="download-link" href="#" class="hidden">Scarica foto</a>
    
    <div class="result-actions" id="action-buttons"></div>
  </div>
</div>

<div id="start-screen" class="overlay">
  <h1 style="color:#fff;margin-bottom:20px" aria-hidden="true">Visione AI</h1>
  <div id="loader" class="loader hidden"></div>
  <div id="load-msg" class="hidden" style="color:#fff;font-size:1.2rem">Avvio sensori...</div>
  <button id="btn-start" onclick="startApp()" style="padding:40px;font-size:1.8rem;background:#D4AF37;color:#000;border-radius:15px;width:95%;border:4px solid #fff;font-weight:bold">AVVIA SISTEMA</button>
</div>

<div id="key-screen" class="overlay hidden" aria-hidden="true" inert>
  <h2 style="color:#fff">Chiave Gemini API</h2>
  <input type="text" id="key-input" placeholder="Incolla chiave qui..." style="width:80%;padding:15px;font-size:1.2rem;margin-bottom:20px;border-radius:8px">
  <button onclick="saveKey()" style="padding:15px;background:#fff;color:#000;width:50%;font-weight:bold;border-radius:8px;margin-bottom:10px">SALVA</button>
  <button onclick="closeSettings()" style="padding:15px;background:#333;color:#fff;width:50%;border-radius:8px">CHIUDI</button>
  <p style="width:80%;margin-top:20px;font-size:0.9rem;color:#ddd;text-align:center">
    Le foto usate per analisi AI vengono inviate a un servizio esterno (Gemini).
  </p>
</div>

<script>
let GEMINI_KEY = localStorage.getItem('gemini_key') || "";
const MODEL_NAME = "gemini-2.0-flash-exp"; 
const API_ENDPOINT = "v1beta";

// MODELLI VISIVI
let audioCtx, lightOsc, lightGain;
let objectDetector = null;
let poseLandmarker = null;
let faceLandmarker = null;

let modelsReady = { detector:false, pose:false, face:false };
let guideVerbosity = 'standard'; // 'breve' | 'standard' | 'dettagliata'

// stato guida per evitare spam ma ricordare ogni 5s
let lastGuideType = null;
let lastGuideText = "";
let lastGuideSpeakTime = 0;

// stato autoscatto
let autoShotTimer = null;
let autoShotMode = null;          // 'selfie_face' | 'selfie_full' | 'object'
let lastGuidancePublishable = false;

let isRunning = false, stream = null;
const tempCanvas = document.createElement('canvas');
let tempCtx = tempCanvas.getContext('2d',{willReadFrequently:true});
let mode = 'idle', lightActive = false, colorActive = false, levelActive = false, discreteMode = false;
let lastSpeak = 0, centeredFrames = 0, lastGuideMessageTime = 0;
let lastLowLightWarning = 0; 
let lastLightAnnounce = 0; 
let currentFacingMode = 'environment'; 
const video = document.getElementById('webcam'),
      canvas = document.getElementById('overlay'),
      ctx = canvas.getContext('2d');
let lastShotB64 = null;
let targetClass = null;
let hasPerformedSocialCheck = false;

// Dizionario nomi oggetti
const objectDict = {
  'person': 'Persona', 'cup': 'Tazza', 'chair': 'Sedia', 'bottle': 'Bottiglia', 
  'cell phone': 'Cellulare', 'laptop': 'Computer', 'book': 'Libro', 
  'tv': 'TV', 'potted plant': 'Pianta', 'keyboard': 'Tastiera', 
  'mouse': 'Mouse', 'remote': 'Telecomando', 'dining table': 'Tavolo',
  'cat': 'Gatto', 'dog': 'Cane', 'bowl': 'Ciotola', 'car': 'Auto', 
  'bicycle': 'Bici', 'motorcycle': 'Moto', 'bed': 'Letto', 'couch': 'Divano',
  'sofa': 'Divano', 'toilet': 'WC', 'vase': 'Vaso', 'suitcase': 'Valigia',
  'backpack': 'Zaino', 'refrigerator': 'Frigorifero', 'fridge': 'Frigorifero'
};

// Costanti guida / bounding box
const BOUND_MARGIN = 0.02;
const CENTER_LEFT = 0.35;
const CENTER_RIGHT = 0.65;
const LOOSE_LEFT = 0.25;
const LOOSE_RIGHT = 0.75;
const LARGE_OBJ_SIZE = 0.6;
const MIN_CENTER_FRAMES = 8;

let smoothCx = null;
function smoothCenter(cx) {
  if (smoothCx === null) smoothCx = cx;
  smoothCx = smoothCx * 0.7 + cx * 0.3;
  return smoothCx;
}

// GESTIONE VOCALE (solo per SCATTA/STOP, NON per scegliere oggetti)
let recognition = null, voiceActive = false;
const voiceStatus = document.getElementById('voice-status');

if ('webkitSpeechRecognition' in window) {
  recognition = new webkitSpeechRecognition();
  recognition.continuous = true;
  recognition.interimResults = false;
  recognition.lang = 'it-IT';
  recognition.onresult = (e) => {
    const t = e.results[e.results.length-1][0].transcript.trim().toLowerCase();
    if (t.includes("scatta")) {
      startCountdown();
    } else if (t.includes("stop") || t.includes("basta")) {
      if (targetClass) manualFind(); 
      else if (mode === 'guiding') toggleGuidance();
      announce("Stop.");
    }
  };
  recognition.onerror = () => {
    if (voiceActive) setTimeout(() => recognition.start(), 1000);
  };
}

function toggleVoiceControl(){
  if(!recognition){announce("Comandi vocali non supportati su questo dispositivo.");return;}
  voiceActive = !voiceActive;
  const b = document.getElementById('btn-voice');
  if(voiceActive){
    recognition.start();
    b.classList.add('active-tool');b.innerText="üéôÔ∏è VOCE: ON";
    if(voiceStatus){voiceStatus.style.display='block';voiceStatus.classList.add('listening');}
    announce("Comandi vocali attivati.");
  }else{
    recognition.stop();
    b.classList.remove('active-tool');b.innerText="COMANDI VOCALI (OPZ)";
    if(voiceStatus){voiceStatus.style.display='none';voiceStatus.classList.remove('listening');}
    announce("Comandi vocali disattivati.");
  }
}

function manualFind(){
  if(!objectDetector){
    announce("Modello oggetti non ancora caricato. Attendi o riavvia.");
    return;
  }

  const b = document.getElementById('btn-find');
  if(targetClass){
    targetClass = null;
    b.innerText = "üîç CERCA OGGETTO (MANUALE)";
    b.classList.remove('searching');
    const choiceDiv = document.getElementById('object-choice');
    if(choiceDiv) choiceDiv.innerHTML = "";
    announce("Ricerca oggetto terminata.");
    return;
  }
  const input = prompt("Scrivi cosa cercare:");
  if(!input) return;
  const query = input.trim().toLowerCase();
  let foundKey = null; let foundName = "";
  for(let [eng, ita] of Object.entries(objectDict)){
    if(ita.toLowerCase() === query || eng === query){ foundKey = eng; foundName = ita; break; }
  }
  if(foundKey){
    targetClass = foundKey;
    b.innerText = "‚ùå STOP RICERCA: " + foundName.toUpperCase();
    b.classList.add('searching');
    announce("Ok, cerco: " + foundName);
    if(mode !== 'guiding') toggleGuidance();
  } else {
    announce("Oggetto non riconosciuto nella lista.");
  }
}

function announce(t){
  if(!discreteMode){
    const e = document.getElementById('sr-announcer');
    e.textContent = "";
    setTimeout(()=>e.textContent=t,50);
  }
}
function vibrate(p){ if(navigator.vibrate) navigator.vibrate(p); }

// Guida: livelli di verbosit√†
function updateGuideModeLabel(){
  const b = document.getElementById('btn-guide-mode');
  if(!b) return;
  let label = "STANDARD";
  if(guideVerbosity === 'breve') label = "BREVE";
  else if(guideVerbosity === 'dettagliata') label = "DETTAGLIATA";
  b.innerText = "GUIDA: " + label;
}

function cycleGuideMode(){
  if(guideVerbosity === 'breve') guideVerbosity = 'standard';
  else if(guideVerbosity === 'standard') guideVerbosity = 'dettagliata';
  else guideVerbosity = 'breve';
  updateGuideModeLabel();
  if(guideVerbosity === 'breve') announce("Guida in modalit√† breve.");
  else if(guideVerbosity === 'standard') announce("Guida in modalit√† standard.");
  else announce("Guida in modalit√† dettagliata.");
}

// guida in base al tipo, con reminder ogni 5s
function guideSpeak(type, fullMsg){
  let msg = fullMsg || "";
  if(guideVerbosity === 'breve'){
    switch(type){
      case 'left': msg = "Sinistra"; break;
      case 'right': msg = "Destra"; break;
      case 'up': msg = "Su"; break;
      case 'down': msg = "Gi√π"; break;
      case 'ok': msg = "Ok"; break;
      default: msg = "Regola la posizione."; break;
    }
  }
  const now = Date.now();
  const same = (type === lastGuideType && msg === lastGuideText);
  if(same && (now - lastGuideSpeakTime) < 5000) return;
  announce(msg);
  lastGuideType = type;
  lastGuideText = msg;
  lastGuideSpeakTime = now;
}

// autoscatto dalla guida
function scheduleAutoShot(modeName, msgPrefix){
  if(autoShotTimer) return;
  autoShotMode = modeName || null;
  const prefix = msgPrefix || "";
  guideSpeak('ok', (prefix ? prefix + " " : "") + "Scatto tra 3 secondi, resta ferma.");
  autoShotTimer = setTimeout(()=>{
    autoShotTimer = null;
    autoShotMode = null;
    if(mode !== 'guiding') return;
    playShutter();
    vibrate(200);
    lastShotB64 = captureFrame();
    onPhotoCaptured('auto');
  }, 3000);
}

function cancelAutoShot(){
  if(autoShotTimer){
    clearTimeout(autoShotTimer);
    autoShotTimer = null;
    autoShotMode = null;
  }
  lastGuidancePublishable = false;
}

function showCameraOnly(){
  const res = document.getElementById('result-screen');
  const cam = document.getElementById('camera-controls');
  res.classList.add('hidden');
  res.setAttribute('aria-hidden','true');
  res.setAttribute('inert','');
  cam.classList.remove('hidden');
  cam.removeAttribute('aria-hidden');
  cam.removeAttribute('inert');
  setTimeout(()=>document.getElementById('btn-shot').focus(),200);
}

function showResultOnly(text){
  const res = document.getElementById('result-screen');
  const cam = document.getElementById('camera-controls');
  cam.classList.add('hidden');
  cam.setAttribute('aria-hidden','true');
  cam.setAttribute('inert','');
  res.classList.remove('hidden');
  res.removeAttribute('aria-hidden');
  res.removeAttribute('inert');
  const c = document.getElementById('result-content');
  c.textContent = text || "";
  setTimeout(()=>c.focus(),200);
  renderResultButtons(); 
}

// quando una foto √® stata catturata
function onPhotoCaptured(origin){
  if(!lastShotB64){
    announce("Errore nello scatto.");
    return;
  }
  hasPerformedSocialCheck = false;
  const dLink = document.getElementById('download-link');
  dLink.href = "data:image/jpeg;base64,"+lastShotB64;
  dLink.download = "foto_visione_" + Date.now() + ".jpg";
  dLink.classList.remove('hidden');

  showResultOnly("Foto scattata. Scegli se usarla cos√¨ o che tipo di analisi vuoi.");
  vibrate(200);
}

// PULSANTI DINAMICI DOPO LO SCATTO
function renderResultButtons(){
  const container = document.getElementById('action-buttons');
  container.innerHTML = ''; 
  if(!lastShotB64) return;

  const btnUse = document.createElement('button');
  btnUse.className = 'btn-primary-wide';
  btnUse.innerText = 'üì∑ USA FOTO SENZA ANALISI';
  btnUse.onclick = usePhoto;
  container.appendChild(btnUse);

  const btnScene = document.createElement('button');
  btnScene.className = 'btn-analyze';
  btnScene.innerText = 'SCENA GENERALE';
  btnScene.onclick = ()=>processAnalysis('scene');
  container.appendChild(btnScene);

  const btnSelfieFace = document.createElement('button');
  btnSelfieFace.className = 'btn-analyze';
  btnSelfieFace.innerText = 'SELFIE VOLTO';
  btnSelfieFace.onclick = ()=>processAnalysis('selfie_face');
  container.appendChild(btnSelfieFace);

  const btnSelfieFull = document.createElement('button');
  btnSelfieFull.className = 'btn-analyze';
  btnSelfieFull.innerText = 'SELFIE CORPO INTERO';
  btnSelfieFull.onclick = ()=>processAnalysis('selfie_full');
  container.appendChild(btnSelfieFull);

  const btnText = document.createElement('button');
  btnText.className = 'btn-analyze';
  btnText.innerText = 'TESTO';
  btnText.onclick = ()=>processAnalysis('text');
  container.appendChild(btnText);

  const btnObject = document.createElement('button');
  btnObject.className = 'btn-analyze';
  btnObject.innerText = 'OGGETTO';
  btnObject.onclick = ()=>processAnalysis('object');
  container.appendChild(btnObject);

  if(!hasPerformedSocialCheck){
    const btnSocial = document.createElement('button');
    btnSocial.className = 'btn-social-check';
    btnSocial.innerText = 'ANALISI SOCIAL';
    btnSocial.onclick = performSocialCheck;
    container.appendChild(btnSocial);
  } else {
    const btnTextAI = document.createElement('button');
    btnTextAI.className = 'btn-add-text';
    btnTextAI.innerText = 'AGGIUNGI SCRITTA AI';
    btnTextAI.onclick = startTextAddition;
    container.appendChild(btnTextAI);
  }

  const btnReview = document.createElement('button');
  btnReview.className = 'btn-analyze';
  btnReview.innerText = 'DOMANDA SU QUESTA FOTO';
  btnReview.onclick = editAndReviewPhoto;
  container.appendChild(btnReview);

  const btnDel = document.createElement('button');
  btnDel.className = 'btn-danger';
  btnDel.innerText = 'ELIMINA FOTO';
  btnDel.onclick = deletePhoto;
  container.appendChild(btnDel);
}

// setupCamera con fallback & messaggi chiari
async function setupCamera(facing, isRetry=false){
  if(stream) stream.getTracks().forEach(t=>t.stop());
  try {
    stream = await navigator.mediaDevices.getUserMedia({ 
      video: { facingMode: facing, width: { ideal: 640 }, height: { ideal: 360 } } 
    });
    video.srcObject = stream; 
    await video.play();
    canvas.width = video.videoWidth; 
    canvas.height = video.videoHeight;
    tempCanvas.width = video.videoWidth; 
    tempCanvas.height = video.videoHeight;
    if(!isRetry){
      if(facing === 'environment'){
        announce("Sto usando la fotocamera posteriore o quella principale.");
      }else{
        announce("Sto usando la fotocamera frontale.");
      }
    }
  } catch(e) { 
    console.error(e);
    if(!isRetry && facing === 'environment'){
      announce("Fotocamera posteriore non disponibile, passo a quella frontale.");
      currentFacingMode = 'user';
      await setupCamera('user', true);
    } else if(!isRetry && facing === 'user'){
      announce("Fotocamera frontale non disponibile, provo quella posteriore.");
      currentFacingMode = 'environment';
      await setupCamera('environment', true);
    } else {
      announce("Errore nell'accesso alla fotocamera.");
    }
  }
}

async function flipCamera(){
  currentFacingMode = (currentFacingMode === 'environment') ? 'user' : 'environment';
  vibrate(50); 
  await setupCamera(currentFacingMode);
  announce(currentFacingMode === 'user' ? "Fotocamera frontale." : "Fotocamera posteriore.");
}

function captureFrame(){
  if(!video.videoWidth || !video.videoHeight || !tempCtx){
    console.warn("Frame non pronto per lo scatto.");
    return null;
  }
  if(tempCanvas.width!==video.videoWidth){
    tempCanvas.width = video.videoWidth;
    tempCanvas.height = video.videoHeight;
  }
  tempCtx.drawImage(video,0,0,tempCanvas.width,tempCanvas.height);
  const dataUrl = tempCanvas.toDataURL('image/jpeg',0.8);
  const parts = dataUrl.split(',');
  if(parts.length<2) return null;
  return parts[1];
}

// SCATTO MANUALE
async function startCountdown() {
  if(mode === 'guiding') toggleGuidance(); 
  cancelAutoShot();

  for(let i=5;i>=1;i--){
    announce(String(i));
    vibrate(50);
    await new Promise(r => setTimeout(r, 1000));
  }
  
  announce("Click"); 
  playShutter(); 
  vibrate(200);
  lastShotB64 = captureFrame();
  onPhotoCaptured('manual');
}
async function takeShot(){ await startCountdown(); }

function playShutter(){
  if(!discreteMode && audioCtx){
    if(audioCtx.state === 'suspended') audioCtx.resume();
    const o = audioCtx.createOscillator(), g = audioCtx.createGain();
    g.gain.value = 0.1;
    o.frequency.value = 600;
    o.connect(g); g.connect(audioCtx.destination);
    o.start(); o.stop(audioCtx.currentTime+0.1);
  }
}

function toggleGuidance(){
  if(!modelsReady.detector && !modelsReady.pose && !modelsReady.face){
    announce("Guida non disponibile: modelli non caricati o errore.");
    return;
  }
  const b = document.getElementById('btn-guide');
  vibrate(50);
  if(mode === 'guiding'){
    mode = 'idle';
    b.classList.remove('guiding');
    b.innerText = "GUIDA SCENA LIVE";
    ctx.clearRect(0,0,canvas.width,canvas.height);
    cancelAutoShot();
    announce("Guida disattivata.");
  }else{
    mode = 'guiding';
    centeredFrames = 0;
    lastGuideMessageTime = 0;
    lastGuideType = null;
    lastGuideText = "";
    lastGuidancePublishable = false;
    b.classList.add('guiding');
    b.innerText = "GUIDA ATTIVA";
    announce("Guida attivata. Cerco selfie e oggetti pubblicabili; se va bene, scatto io dopo un breve conto alla rovescia.");
  }
}

// GUIDA LIVE
function processGuidance(){
  if(tempCtx && Date.now() - lastLowLightWarning > 8000) {
    const size = 100; 
    const startX = Math.max(0, tempCanvas.width/2 - size/2);
    const startY = Math.max(0, tempCanvas.height/2 - size/2);
    const p = tempCtx.getImageData(startX, startY, size, size).data;
    let total = 0, count = 0;
    for(let i=0; i<p.length; i+=40) { 
      total += (p[i] + p[i+1] + p[i+2]) / 3; 
      count++; 
    }
    if(count>0 && (total / count) < 40) { 
      announce("Luce molto bassa, il selfie potrebbe venire scuro."); 
      lastLowLightWarning = Date.now(); 
    }
  }

  if(video.readyState < 2 || !tempCtx) return;

  const imgW = video.videoWidth;
  const imgH = video.videoHeight;
  const rx = canvas.width / imgW;
  const ry = canvas.height / imgH;

  ctx.clearRect(0,0,canvas.width,canvas.height);

  const now = Date.now();

  // SELFIE: camera frontale, niente targetClass
  if(currentFacingMode === 'user' && (poseLandmarker || faceLandmarker) && !targetClass){
    try{
      let poseResult = null;
      if(poseLandmarker){
        poseResult = poseLandmarker.detectForVideo(video, performance.now());
      }

      let box = null;
      if(poseResult && poseResult.landmarks && poseResult.landmarks.length){
        const lm = poseResult.landmarks[0];

        let xMin = 1, xMax = 0, yMin = 1, yMax = 0;
        lm.forEach(p=>{
          if(p.x < xMin) xMin = p.x;
          if(p.x > xMax) xMax = p.x;
          if(p.y < yMin) yMin = p.y;
          if(p.y > yMax) yMax = p.y;
        });

        xMin = Math.max(0, Math.min(1, xMin));
        xMax = Math.max(0, Math.min(1, xMax));
        yMin = Math.max(0, Math.min(1, yMin));
        yMax = Math.max(0, Math.min(1, yMax));

        box = {
          originX: xMin * imgW,
          originY: yMin * imgH,
          width: (xMax - xMin) * imgW,
          height: (yMax - yMin) * imgH
        };
      }

      let faceBox = null;
      if(faceLandmarker){
        const faceRes = faceLandmarker.detectForVideo(video, performance.now());
        if(faceRes && faceRes.faceLandmarks && faceRes.faceLandmarks.length){
          const fLm = faceRes.faceLandmarks[0];
          let fxMin=1, fxMax=0, fyMin=1, fyMax=0;
          fLm.forEach(p=>{
            if(p.x<fxMin) fxMin=p.x;
            if(p.x>fxMax) fxMax=p.x;
            if(p.y<fyMin) fyMin=p.y;
            if(p.y>fyMax) fyMax=p.y;
          });
          fxMin = Math.max(0, Math.min(1, fxMin));
          fxMax = Math.max(0, Math.min(1, fxMax));
          fyMin = Math.max(0, Math.min(1, fyMin));
          fyMax = Math.max(0, Math.min(1, fyMax));
          faceBox = {
            originX: fxMin*imgW,
            originY: fyMin*imgH,
            width: (fxMax-fxMin)*imgW,
            height: (fyMax-fyMin)*imgH
          };
        }
      }

      if(!box && !faceBox){
        if(now - lastGuideMessageTime > 3000){
          guideSpeak('warn',"Non ti vedo nel riquadro. Avvicinati o entra meglio nella camera.");
          lastGuideMessageTime = now;
        }
        if(lastGuidancePublishable) cancelAutoShot();
        return;
      }

      if(!box && faceBox){
        box = {
          originX: faceBox.originX - faceBox.width,
          originY: Math.max(0, faceBox.originY - faceBox.height * 1.5),
          width: faceBox.width * 3,
          height: faceBox.height * 3
        };
      }

      let dynamicSelfieMode = 'face';
      if(box){
        const hRatio = box.height / imgH;
        if(hRatio > 0.5){
          dynamicSelfieMode = 'full';
        }
      }

      if(box){
        ctx.strokeStyle="#FFD700";
        ctx.lineWidth=4;
        ctx.strokeRect(
          box.originX*rx,
          box.originY*ry,
          box.width*rx,
          box.height*ry
        );
      }

      if(now - lastGuideMessageTime > 1200){
        const xMinPx = box ? box.originX : (faceBox ? faceBox.originX : imgW/2);
        const xMaxPx = box ? box.originX + box.width : (faceBox ? faceBox.originX + faceBox.width : imgW/2);
        const yMinPx = box ? box.originY : (faceBox ? faceBox.originY : imgH/2);
        const yMaxPx = box ? box.originY + box.height : (faceBox ? faceBox.originY + faceBox.height : imgH/2);

        const cxNorm = (xMinPx + (xMaxPx - xMinPx)/2) / imgW;

        let msg = "";
        let type = 'warn';
        let publishable = false;

        const severeHeadCut = faceBox && faceBox.originY < imgH * BOUND_MARGIN;
        const severeBodyCut =
          (dynamicSelfieMode === 'full') &&
          yMaxPx > imgH * (1 - BOUND_MARGIN) &&
          box && box.height > imgH * 0.6;

        if(severeHeadCut){
          msg = "Testa tagliata in alto. Cos√¨ il selfie non √® pubblicabile. Abbassa la camera.";
          type = 'down';
          publishable = false;
        }
        else if(severeBodyCut){
          msg = "Corpo molto tagliato in basso. Cos√¨ il selfie corpo intero non √® pubblicabile. Alza o allontana la camera.";
          type = 'up';
          publishable = false;
        }
        else {
          if(faceBox && faceBox.originY > imgH * 0.4){
            msg = "Selfie pubblicabile ma migliorabile: il volto √® piuttosto in basso, puoi alzare un po' la camera.";
            type = 'up';
            publishable = true;
          } else {
            if(cxNorm < LOOSE_LEFT){
              msg = "Selfie pubblicabile ma molto a sinistra. Se vuoi un effetto pi√π classico, spostati un po' a destra.";
              type = 'right';
              publishable = true;
            } else if(cxNorm > LOOSE_RIGHT){
              msg = "Selfie pubblicabile ma molto a destra. Puoi spostarti un po' a sinistra se preferisci.";
              type = 'left';
              publishable = true;
            } else if(cxNorm < CENTER_LEFT){
              msg = "Selfie pubblicabile. Sei leggermente a sinistra nel riquadro.";
              type = 'ok';
              publishable = true;
            } else if(cxNorm > CENTER_RIGHT){
              msg = "Selfie pubblicabile. Sei leggermente a destra nel riquadro.";
              type = 'ok';
              publishable = true;
            } else {
              msg = (dynamicSelfieMode === 'full')
                ? "Selfie corpo intero pubblicabile. Sei ben centrata."
                : "Selfie volto pubblicabile. Sei ben centrata.";
              type = 'ok';
              publishable = true;
              if(navigator.vibrate) navigator.vibrate([50,100,50]);
            }
          }
        }

        guideSpeak(type, msg);
        lastGuideMessageTime = now;

        if(publishable){
          if(!lastGuidancePublishable){
            scheduleAutoShot(
              dynamicSelfieMode === 'full' ? 'selfie_full' : 'selfie_face',
              "Selfie pubblicabile."
            );
          }
          lastGuidancePublishable = true;
        } else {
          if(lastGuidancePublishable){
            cancelAutoShot();
          }
          lastGuidancePublishable = false;
        }
      }
      return;
    }catch(e){
      console.error(e);
    }
  }

  // OGGETTI / GENERALE
  if(!objectDetector) return;

  try{
    const r = objectDetector.detectForVideo(video, performance.now());
    const d = r ? r.detections : [];
    
    let relevantObjects = [];
    if(targetClass) {
      relevantObjects = d.filter(o => o.categories[0].categoryName === targetClass);
      if(relevantObjects.length === 0 && d.length > 0 && now - lastGuideMessageTime > 3000) {
        const visible = d.slice(0,3).map(o=> objectDict[o.categories[0].categoryName] || o.categories[0].categoryName).join(", ");
        guideSpeak('warn',"Cerco " + (objectDict[targetClass] || targetClass) + " ma vedo solo: " + visible);
        lastGuideMessageTime = now;
        if(lastGuidancePublishable) cancelAutoShot();
        return;
      } else if(relevantObjects.length === 0){
        if(lastGuidancePublishable) cancelAutoShot();
        return;
      }
    } else {
      relevantObjects = d;
    }

    if(!relevantObjects.length){
      if(now - lastGuideMessageTime > 4000){
        guideSpeak('warn',"Non vedo oggetti rilevanti.");
        lastGuideMessageTime = now;
      }
      if(lastGuidancePublishable) cancelAutoShot();
      return;
    }

    relevantObjects.forEach(obj => {
      const b = obj.boundingBox;
      ctx.strokeStyle = targetClass ? "#FFD700" : "#0f0"; 
      ctx.lineWidth = 4;
      ctx.strokeRect(
        b.originX*rx, 
        b.originY*ry, 
        b.width*rx, 
        b.height*ry
      );
    });

    if (now - lastGuideMessageTime > 2000) { 
      const sorted = relevantObjects.slice().sort(
        (a,b)=>b.boundingBox.width*b.boundingBox.height - a.boundingBox.width*a.boundingBox.height
      );
      const mainObj = sorted[0]; 
      const box = mainObj.boundingBox;
      
      const xMin = box.originX; 
      const xMax = box.originX + box.width;
      const yMin = box.originY;
      const yMax = box.originY + box.height;

      const rawName = mainObj.categories[0].categoryName;
      const mainName = objectDict[rawName] || rawName;

      let msg = "";
      let type = 'warn';
      let publishable = false;
      
      let LIMIT_LEFT = CENTER_LEFT; 
      let LIMIT_RIGHT = CENTER_RIGHT;
      const isSelfie = (currentFacingMode === 'user');
      const isPerson = (mainName === 'Persona');

      const isLargeObject = box.width > imgW * LARGE_OBJ_SIZE || box.height > imgH * LARGE_OBJ_SIZE;
      if(isLargeObject){
        LIMIT_LEFT = 0.30;
        LIMIT_RIGHT = 0.70;
      }

      let effectiveHeight = box.height;
      if (isPerson) {
        effectiveHeight = box.height * 0.35; 
      }
      
      const focusCenterY = box.originY + (effectiveHeight / 2);
      const focusCenterX = box.originX + (box.width / 2); 
      const cx = smoothCenter(focusCenterX / imgW);
      
      const txtLeft  = isSelfie ? "Sposta a destra." : "Ruota a sinistra.";
      const txtRight = isSelfie ? "Sposta a sinistra." : "Ruota a destra.";

      const severelyCutTop = yMin < (imgH * BOUND_MARGIN));
      const severelyCutBottom = yMax > (imgH * (1 - BOUND_MARGIN));

      if (severelyCutTop) {
        msg = mainName + " tagliato in alto. Cos√¨ la foto non √® ideale. Abbassa un po' la camera.";
        type = 'down';
        centeredFrames = 0;
        publishable = false;
      } 
      else if (severelyCutBottom && !isPerson && !isSelfie) {
        msg = mainName + " molto tagliato in basso. Per una foto migliore, alza la camera.";
        type = 'up';
        centeredFrames = 0;
        publishable = false;
      }
      else if (xMin < (imgW * BOUND_MARGIN)) {
        msg = mainName + " quasi fuori da un lato. " + txtLeft;
        type = isSelfie ? 'right' : 'left';
        centeredFrames = 0;
        publishable = false;
      }
      else if (xMax > (imgW * (1 - BOUND_MARGIN))) {
        msg = mainName + " quasi fuori dall'altro lato. " + txtRight;
        type = isSelfie ? 'left' : 'right';
        centeredFrames = 0;
        publishable = false;
      }
      else {
        if (cx < LIMIT_LEFT){
          msg = mainName + " visibile ma spostato. " + txtLeft;
          type = isSelfie ? 'right' : 'left';
          centeredFrames = Math.max(0, centeredFrames - 2);
          publishable = true; // pubblicabile ma migliorabile
        }
        else if (cx > LIMIT_RIGHT){
          msg = mainName + " visibile ma spostato. " + txtRight;
          type = isSelfie ? 'left' : 'right';
          centeredFrames = Math.max(0, centeredFrames - 2);
          publishable = true;
        }
        else {
          if (isPerson && yMin > (imgH * 0.20)) {
            msg = "Persona un po' bassa nell'inquadratura. Pubblicabile ma puoi alzare la camera per migliorare.";
            type = 'up';
            centeredFrames = 0;
            publishable = true;
          } else {
            centeredFrames++;
            if(centeredFrames >= MIN_CENTER_FRAMES){
              msg = mainName + " centrato, foto ben messa. Pubblicabile.";
              type = 'ok';
              publishable = true;
              if(navigator.vibrate) navigator.vibrate([50,100,50]); 
            } else {
              msg = mainName + " quasi centrato, piccole regolazioni se vuoi.";
              type = 'ok';
              publishable = true;
            }
          }
        }
      }
      guideSpeak(type, msg); 
      lastGuideMessageTime = now;

      if(publishable){
        if(!lastGuidancePublishable){
          scheduleAutoShot('object', mainName + " pubblicabile.");
        }
        lastGuidancePublishable = true;
      } else {
        if(lastGuidancePublishable){
          cancelAutoShot();
        }
        lastGuidancePublishable = false;
      }
    }
  }catch(e){ 
    console.error(e); 
  }
}

function toggleLight(){
  lightActive = !lightActive;
  const b = document.getElementById('btn-light');
  vibrate(50);
  if(lightActive){
    if(audioCtx.state === 'suspended') audioCtx.resume();
    lightOsc = audioCtx.createOscillator();
    lightGain = audioCtx.createGain();
    lightOsc.connect(lightGain);lightGain.connect(audioCtx.destination);
    lightGain.gain.value = 0;
    lightOsc.start();
    lastLightAnnounce = Date.now();
    b.classList.add('active-tool');
    b.innerText = "LUCE: ON";
    announce("Sonda luce attivata.");
  }else{
    if(lightOsc){lightOsc.stop();lightOsc.disconnect();}
    b.classList.remove('active-tool');
    b.innerText = "LUCE";
    announce("Sonda luce disattivata.");
  }
}
function processLight(){
  if(!tempCtx || !lightOsc) return;
  const p = tempCtx.getImageData(tempCanvas.width/2-10,tempCanvas.height/2-10,20,20).data;
  let s = 0; 
  for(let i=0;i<p.length;i+=4)s+=(p[i]+p[i+1]+p[i+2])/3;
  const level = s/(p.length/4); 
  lightGain.gain.setTargetAtTime(0.02+(level/255)*0.1,audioCtx.currentTime,0.1);
  lightOsc.frequency.setTargetAtTime(100+level*4,audioCtx.currentTime,0.1);
  if(Date.now() - lastLightAnnounce > 3000) {
    const percent = Math.round((level/255)*100);
    announce("Luce circa " + percent + " percento.");
    lastLightAnnounce = Date.now();
  }
}
function toggleColor(){
  colorActive = !colorActive;
  const b = document.getElementById('btn-color');
  vibrate(50);
  if(colorActive){
    b.classList.add('active-tool');
    b.innerText = "COLORE: ON";
    announce("Sonda colore attivata.");
  } else {
    b.classList.remove('active-tool');
    b.innerText = "COLORE";
    announce("Sonda colore disattivata.");
  }
}

// conversione colore (HSV)
function rgbToHsv(r, g, b){
  r /= 255; g /= 255; b /= 255;
  const max = Math.max(r,g,b), min = Math.min(r,g,b);
  const d = max - min;
  let h = 0;
  const s = max === 0 ? 0 : d / max;
  const v = max;
  if(d !== 0){
    switch(max){
      case r: h = ((g - b) / d + (g < b ? 6 : 0)); break;
      case g: h = ((b - r) / d + 2); break;
      case b: h = ((r - g) / d + 4); break;
    }
    h *= 60;
  }
  return { h, s, v };
}

function describeColor(r,g,b){
  const {h,s,v} = rgbToHsv(r,g,b);
  if(v < 0.15) return "Nero o molto scuro";
  if(v > 0.9 && s < 0.2) return "Bianco o molto chiaro";
  if(s < 0.2) return "Grigio o colore poco saturo";

  if(h < 15 || h >= 345) return "Rosso";
  if(h < 45) return "Arancione";
  if(h < 70) return "Giallo";
  if(h < 160) return "Verde";
  if(h < 250) return "Blu";
  if(h < 290) return "Viola";

  return "Colore indefinito";
}

function processColor(){
  if(Date.now()-lastSpeak<2000 || !tempCtx)return;
  const size = 20;
  const p = tempCtx.getImageData(tempCanvas.width/2 - size/2, tempCanvas.height/2 - size/2, size, size).data;
  let rT=0, gT=0, bT=0;
  for(let i=0; i<p.length; i+=4) { rT += p[i]; gT += p[i+1]; bT += p[i+2]; }
  const count = p.length/4;
  if(count === 0) return;
  const r = rT/count; const g = gT/count; const b = bT/count;
  const desc = describeColor(r,g,b);
  announce(desc);
  lastSpeak=Date.now();
}

function toggleLevel(){
  const b=document.getElementById('btn-level');vibrate(50);
  if(levelActive){
    levelActive=false;b.classList.remove('active-tool');b.innerText="LIVELLA";
    announce("Livella disattivata.");window.removeEventListener('deviceorientation',handleLevel);
  }else{
    const enable=()=>{
      levelActive=true;
      b.classList.add('active-tool');b.innerText="LIVELLA: ON";
      announce("Livella attivata.");
      window.addEventListener('deviceorientation',handleLevel);
    };
    if(typeof DeviceOrientationEvent!=='undefined'&&typeof DeviceOrientationEvent.requestPermission==='function'){
      DeviceOrientationEvent.requestPermission().then(r=>{if(r==='granted')enable();}).catch(()=>{announce("Permesso sensori negato.");});
    }else enable();
  }
}
function handleLevel(e){
  if(!levelActive||Date.now()-lastSpeak<1500)return;
  const t=e.gamma||0;
  if(t>10){announce("Destra");vibrate(20);lastSpeak=Date.now();}
  else if(t<-10){announce("Sinistra");vibrate(20);lastSpeak=Date.now();}
}
function toggleDiscrete(){
  discreteMode = !discreteMode;
  document.getElementById('btn-discrete').classList.toggle('active-discrete');
  vibrate(200);
  if(!discreteMode)announce("Voce attiva.");
}

async function callGemini(prompt,b64){
  try{
    const r=await fetch(`https://generativelanguage.googleapis.com/${API_ENDPOINT}/models/${MODEL_NAME}:generateContent?key=${GEMINI_KEY}`,{
      method:'POST',
      headers:{'Content-Type':'application/json'},
      body:JSON.stringify({
        contents:[{
          parts:[
            {text:prompt},
            {inline_data:{mime_type:"image/jpeg",data:b64}}
          ]
        }]
      })
    });
    if(!r.ok){
      console.error("Gemini HTTP error", r.status);
      return null;
    }
    const d=await r.json();
    return d.candidates?.[0]?.content?.parts?.map(p=>p.text).join("\n").trim()||"";
  }catch(e){
    console.error("Gemini error", e);
    return null;
  }
}

// PROMPT ANALISI
function buildPrompt(mode){
  let basePrompt = `
Sei un assistente visivo per una persona non vedente.
Devi essere molto chiaro e pratico.

1. VERDETTO RAPIDO FOTO:
- "‚úÖ FOTO VALIDA" se la foto √® tecnicamente leggibile (non sfocata, soggetto non completamente tagliato).
- "‚ùå FOTO NON VALIDA: [Motivo]" se √® davvero problematica (sfocatura forte, soggetto quasi assente).

2. DESCRIZIONE DETTAGLIATA:
`;

  if(mode === 'text'){
    basePrompt += `- Leggi tutto il testo visibile nella foto in ordine logico.`;
  } else if(mode === 'object'){
    basePrompt += `- Descrivi l'oggetto principale a cui sembra essere puntata la camera.`;
  } else if(mode === 'selfie_face'){
    basePrompt += `
- SELFIE VOLTO:
  - Descrivi espressione, viso e parte superiore del corpo.
  - Indica se testa o mento sono tagliati.
  - Indica se il volto √® spostato a sinistra, a destra, troppo in alto o troppo in basso.
  - Distingui chiaramente:
    - "‚úÖ SELFIE PUBBLICABILE": volto intero, occhi visibili, luce sufficiente, anche se il viso √® un po' decentrato.
    - "‚ö†Ô∏è SELFIE PUBBLICABILE MA MIGLIORABILE": i tratti sono visibili ma suggerisci cosa migliorare.
    - "‚ùå SELFIE NON PUBBLICABILE": testa seriamente tagliata, volto quasi invisibile, luce pessima.`;
  } else if(mode === 'selfie_full'){
    basePrompt += `
- SELFIE CORPO INTERO:
  - Controlla se testa, busto e gambe sono nel riquadro (specifica se manca una parte: testa, piedi, ginocchia ecc.).
  - Indica se il corpo √® molto decentrato a sinistra/destra o solo leggermente.
  - Distingui chiaramente:
    - "‚úÖ SELFIE PUBBLICABILE": corpo abbastanza completo e luce sufficiente, anche se non perfettamente centrato.
    - "‚ö†Ô∏è SELFIE PUBBLICABILE MA MIGLIORABILE": tecnicamente ok ma con qualche difetto.
    - "‚ùå SELFIE NON PUBBLICABILE": grosse parti del corpo tagliate o quasi invisibili.`;
  } else {
    basePrompt += `- Descrivi la scena generale in modo chiaro, indicando cosa sembra al centro dell'inquadratura.`;
  }

  basePrompt += `

3. SE NECESSARIO, UN BREVE CONSIGLIO:
- Una frase molto pratica su cosa correggere nel prossimo scatto.`;

  return basePrompt;
}

async function performSocialCheck(){
  if(!GEMINI_KEY){
    announce("Manca la chiave Gemini. Apri le impostazioni.");
    openSettings();return;
  }
  if(!lastShotB64){
    announce("Nessuna foto da analizzare.");
    return;
  }
  announce("Analisi Social in corso...");
  const prompt = `
Analizza questa foto per i Social Media (Instagram/TikTok).
Considera le zone di interfaccia.

1. VERDETTO STORIE (9:16). 
2. VERDETTO POST (4:5 o 1:1).
3. Zone dove √® sicuro mettere testo.`;
  showResultOnly("Analisi Social...");
  const text = await callGemini(prompt, lastShotB64);
  if(!text){
    document.getElementById('result-content').textContent =
      "Non sono riuscita ad analizzare la foto per i social.\n" +
      "Controlla la connessione o la chiave Gemini.\nLa foto √® comunque salvata sul dispositivo.";
    announce("Analisi social non riuscita.");
    return;
  }
  document.getElementById('result-content').textContent = "--- ANALISI SOCIAL ---\n" + text;
  hasPerformedSocialCheck = true; 
  renderResultButtons(); 
  announce("Report Social pronto. Puoi aggiungere testo.");
}

function parsePositionCode(raw){
  const upper = (raw || "").toUpperCase();
  const codes = ["TOP_CENTER","BOTTOM_CENTER","TOP_LEFT","TOP_RIGHT","CENTER"];
  for(const c of codes){
    if(upper.includes(c)) return c;
  }
  return "BOTTOM_CENTER";
}

async function startTextAddition(){
  if(!GEMINI_KEY){announce("Manca chiave Gemini. Apri le impostazioni.");openSettings();return;}
  if(!lastShotB64){announce("Nessuna foto da modificare.");return;}
  const textToAdd = prompt("Cosa vuoi scrivere sulla foto?");
  if(!textToAdd) return;

  announce("Chiedo all'AI dove posizionare il testo...");
  
  const placementPrompt = `
L'utente vuole scrivere: "${textToAdd}".
Decidi dove metterlo senza coprire volto o dettagli importanti.
Rispondi SOLO con:
TOP_CENTER, BOTTOM_CENTER, TOP_LEFT, TOP_RIGHT o CENTER.`;

  const positionCode = await callGemini(placementPrompt, lastShotB64);
  if(!positionCode){
    announce("Non sono riuscita a decidere la posizione del testo.");
    return;
  }
  
  const pos = parsePositionCode(positionCode);
  drawTextOnCanvas(textToAdd, pos);
}

function drawTextOnCanvas(text, position){
  const img = new Image();
  img.onload = function(){
    const c = document.createElement('canvas');
    c.width = img.width; c.height = img.height;
    const ctx2 = c.getContext('2d');
    ctx2.drawImage(img, 0, 0);
    
    const fontSize = c.width * 0.06; 
    ctx2.font = `bold ${fontSize}px Arial`;
    ctx2.fillStyle = "white";
    ctx2.textAlign = "center";
    ctx2.strokeStyle = 'black';
    ctx2.lineWidth = 4;
    
    const maxWidth = c.width * 0.8; 
    const words = text.split(' ');
    let line = '';
    let lines = [];
    
    for(let n = 0; n < words.length; n++) {
      let testLine = line + words[n] + ' ';
      let metrics = ctx2.measureText(testLine);
      let testWidth = metrics.width;
      if (testWidth > maxWidth && n > 0) {
        lines.push(line);
        line = words[n] + ' ';
      } else {
        line = testLine;
      }
    }
    lines.push(line);

    let x = c.width / 2;
    let startY = c.height - (lines.length * fontSize * 1.5) - 50; 

    if(position === 'TOP_CENTER') { startY = 100 + fontSize; }
    else if(position === 'TOP_LEFT') { x = c.width * 0.25; startY = 100 + fontSize; }
    else if(position === 'TOP_RIGHT') { x = c.width * 0.75; startY = 100 + fontSize; }
    else if(position === 'CENTER') { startY = (c.height/2) - ((lines.length * fontSize)/2); }
    
    for(let i = 0; i<lines.length; i++){
      ctx2.strokeText(lines[i], x, startY + (i * fontSize * 1.2));
      ctx2.fillText(lines[i], x, startY + (i * fontSize * 1.2));
    }

    lastShotB64 = c.toDataURL('image/jpeg', 0.9).split(',')[1];
    
    const dLink = document.getElementById('download-link');
    const filename = "foto_visione_edit_" + Date.now() + ".jpg";
    dLink.href = "data:image/jpeg;base64,"+lastShotB64;
    dLink.download = filename;
    dLink.classList.remove('hidden');
    
    reAnalyzeAfterEdit();
  };
  img.src = "data:image/jpeg;base64," + lastShotB64;
}

async function reAnalyzeAfterEdit(){
  if(!GEMINI_KEY){announce("Chiave Gemini mancante. Apri le impostazioni.");return;}
  announce("Testo aggiunto. Controllo finale AI...");
  const prompt = `Ho aggiunto del testo alla foto. Conferma che sia leggibile e non copra elementi importanti. Descrivi il risultato finale.`;
  const text = await callGemini(prompt, lastShotB64);
  const out = document.getElementById('result-content');
  if(!text){
    out.textContent =
      "--- FOTO MODIFICATA ---\n" +
      "Non sono riuscita a fare il controllo finale con l'AI.\n" +
      "Controlla connessione o chiave Gemini. La nuova foto √® comunque salvata.";
    announce("Controllo finale non riuscito.");
    return;
  }
  out.textContent = "--- FOTO MODIFICATA ---\n" + text;
  announce("Foto modificata pronta.");
}

// Analisi su foto gi√† scattata
async function processAnalysis(c){
  if(!lastShotB64){
    announce("Nessuna foto da analizzare.");
    return;
  }
  showResultOnly("Analisi in corso...");
  announce("Analisi AI della foto in corso.");
  const t = await callGemini(buildPrompt(c), lastShotB64);
  const out = document.getElementById('result-content');
  if(!t){
    out.textContent =
      "Non sono riuscita ad analizzare la foto.\n" +
      "Controlla la connessione o la chiave Gemini.\n" +
      "La foto √® comunque salvata sul dispositivo.";
    announce("Analisi non riuscita.");
  } else {
    out.textContent = t;
    announce("Risultato dell'analisi pronto.");
  }
  vibrate(200);
}

// Flusso "chiedi dettaglio": scatta + analisi diretta
async function askCustomDetail(){
  if(!GEMINI_KEY){announce("Manca chiave Gemini. Apri le impostazioni.");openSettings();return;}
  playShutter();
  lastShotB64 = captureFrame();
  if(!lastShotB64){
    announce("Errore nello scatto. Riprova.");
    return;
  }
  const q = prompt("Domanda sulla scena?");
  if(!q){announce("Domanda annullata.");return;}
  showResultOnly("Analisi domanda...");
  announce("Analizzo la foto per rispondere alla domanda.");
  const t = await callGemini("Domanda dell'utente: \""+q+"\". Valida la foto e poi rispondi in modo chiaro.",lastShotB64);
  const out = document.getElementById('result-content');
  if(!t){
    out.textContent = 
      "Non sono riuscita a rispondere alla domanda.\n" +
      "Controlla connessione o chiave Gemini. La foto √® comunque salvata.\n\n" +
      "Domanda: " + q;
    announce("Risposta non disponibile.");
  } else {
    out.textContent = "D: "+q+"\n\nR: "+t;
    announce("Risposta pronta.");
  }
  vibrate(200);
}

async function editAndReviewPhoto(){
  if(!lastShotB64){announce("Nessuna foto caricata.");return;}
  const q=prompt("Altra domanda sulla stessa foto?");
  if(!q)return;
  announce("Analizzo la foto per la nuova domanda.");
  const t=await callGemini("Domanda extra dell'utente: \""+q+"\". Rispondi sulla base di questa foto.",lastShotB64);
  const out = document.getElementById('result-content');
  if(!t){
    out.textContent += "\n\n================\nD: "+q+"\nR: Non sono riuscita a rispondere. Controlla connessione o chiave Gemini.";
    announce("Nuova risposta non disponibile.");
  } else {
    out.textContent += "\n\n================\nD: "+q+"\nR: "+t;
    announce("Risposta aggiunta.");
  }
  vibrate(200);
}

async function usePhoto(){
  if(!lastShotB64){announce("Nessuna foto da usare.");return;}
  const filename = "foto_visione_" + Date.now() + ".jpg";
  
  if(navigator.share && navigator.canShare){
    try {
      const b=await(await fetch("data:image/jpeg;base64,"+lastShotB64)).blob();
      const f=new File([b], filename ,{type:"image/jpeg"});
      if (navigator.canShare({ files: [f] })) {
        await navigator.share({files:[f]});
        announce("Foto condivisa.");
        return;
      }
    } catch(e) { 
      console.log("Share fallito o annullato, uso il download standard."); 
    }
  }
  
  const dLink = document.getElementById('download-link');
  dLink.href = "data:image/jpeg;base64,"+lastShotB64;
  dLink.download = filename;
  dLink.classList.remove('hidden');
  dLink.click();
  announce("Foto scaricata sul dispositivo.");
}

function deletePhoto(){
  lastShotB64=null;
  showCameraOnly();
  announce("Foto scartata. Torno alla camera.");
}

/* ===========================
   SCELTA OGGETTO SENZA VOCE
   =========================== */

function selectObjectFromChoice(eng, ita){
  if(!objectDetector){
    announce("Riconoscimento oggetti non disponibile.");
    return;
  }
  targetClass = eng;
  const b = document.getElementById('btn-find');
  if(b){
    b.innerText = "‚ùå STOP RICERCA: " + ita.toUpperCase();
    b.classList.add('searching');
  }
  const choiceDiv = document.getElementById('object-choice');
  if(choiceDiv) choiceDiv.innerHTML = "";
  if(mode !== 'guiding') toggleGuidance();
  announce("Ok, mi concentro su " + ita + ".");
}

// DESCRIZIONE RAPIDA: COSA VEDE LA CAMERA
function quickDescribeScene(){
  if(!tempCtx || video.readyState < 2){
    announce("La fotocamera non √® pronta.");
    return;
  }

  if(tempCanvas.width!==video.videoWidth){
    tempCanvas.width = video.videoWidth;
    tempCanvas.height = video.videoHeight;
  }
  tempCtx.drawImage(video,0,0,tempCanvas.width,tempCanvas.height);

  if(!objectDetector && !poseLandmarker && !faceLandmarker){
    announce("I modelli di riconoscimento non sono disponibili.");
    return;
  }

  const choiceDiv = document.getElementById('object-choice');
  if(choiceDiv) choiceDiv.innerHTML = "";

  let parts = [];
  let personSeen = false;

  try{
    // persona davanti alla camera
    if(currentFacingMode === 'user' && (poseLandmarker || faceLandmarker)){
      let hasPose = false;
      if(poseLandmarker){
        const poseRes = poseLandmarker.detectForVideo(video, performance.now());
        if(poseRes && poseRes.landmarks && poseRes.landmarks.length){
          hasPose = true;
        }
      }
      let hasFace = false;
      if(!hasPose && faceLandmarker){
        const faceRes = faceLandmarker.detectForVideo(video, performance.now());
        if(faceRes && faceRes.faceLandmarks && faceRes.faceLandmarks.length){
          hasFace = true;
        }
      }
      if(hasPose || hasFace){
        parts.push("Vedo una persona davanti alla camera.");
        personSeen = true;
      }
    }

    let labels = [];
    let options = [];

    if(objectDetector){
      const r = objectDetector.detectForVideo(video, performance.now());
      const d = r ? r.detections : [];
      if(d && d.length){
        const sorted = d.slice().sort((a,b)=>{
          const aa = a.boundingBox.width*a.boundingBox.height;
          const bb = b.boundingBox.width*b.boundingBox.height;
          return bb-aa;
        });

        const counts = {};
        const order = [];
        for(const det of sorted){
          const raw = det.categories[0].categoryName;
          const nice = objectDict[raw] || raw;
          if(!counts[nice]) {
            counts[nice] = 0;
            order.push(nice);
          }
          counts[nice]++;
        }

        // NESSUN LIMITE: TUTTI GLI OGGETTI
        labels = [];
        for(const name of order){
          const c = counts[name];
          if(c > 1) labels.push(name + " ripetuto " + c + " volte");
          else labels.push(name);
        }

        // opzioni per pulsanti: uno per ogni tipo di oggetto rilevato
        options = [];
        for(const name of order){
          let foundEng = null;
          for(const [eng, ita] of Object.entries(objectDict)){
            if(ita === name || eng === name){
              foundEng = eng;
              break;
            }
          }
          if(foundEng){
            options.push({eng:foundEng, ita:name});
          }
        }

        if(labels.length){
          const list = labels.join(", ");
          if(personSeen){
            parts.push("In pi√π vedo: " + list + ".");
          }else{
            parts.push("Vedo: " + list + ".");
          }
        }
      }
    }

    // Se ho opzioni, creo i pulsanti sotto "Cosa vede la camera"
    if(options.length){
      const labelEl = document.createElement('div');
      labelEl.id = 'object-choice-label';
      labelEl.textContent = options.length > 1
        ? "Scegli cosa seguire:"
        : "Vuoi seguire questo oggetto?";
      choiceDiv.appendChild(labelEl);

      for(const opt of options){
        const btn = document.createElement('button');
        btn.type = 'button';
        btn.className = 'small-btn';
        btn.textContent = opt.ita.toUpperCase();
        btn.onclick = ()=>selectObjectFromChoice(opt.eng, opt.ita);
        choiceDiv.appendChild(btn);
      }

      if(options.length > 1){
        parts.push("Puoi scegliere l'oggetto da seguire con i pulsanti sotto.");
      } else {
        parts.push("Puoi seguire questo oggetto con il pulsante sotto.");
      }
    }

  }catch(e){
    console.error("Errore quickDescribeScene", e);
  }

  if(!parts.length){
    announce("Al momento non riconosco persone o oggetti chiari nell'inquadratura.");
  }else{
    announce(parts.join(" "));
  }
}

async function startApp(){
  document.getElementById('main-interface').classList.remove('hidden');
  document.getElementById('main-interface').removeAttribute('aria-hidden');
  document.getElementById('start-screen').classList.add('hidden');
  document.getElementById('start-screen').setAttribute('aria-hidden','true');
  document.getElementById('btn-shot').focus();
  updateGuideModeLabel();
  announce("Visione AI avviata.");
  audioCtx = new (window.AudioContext||window.webkitAudioContext)();
  await setupCamera(currentFacingMode);

  try{
    const {
      ObjectDetector,
      PoseLandmarker,
      FaceLandmarker,
      FilesetResolver
    } = await import("https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/vision_bundle.js");
    
    const vision = await FilesetResolver.forVisionTasks("https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm");
    
    try{
      objectDetector = await ObjectDetector.createFromOptions(vision,{
        baseOptions:{
          modelAssetPath:"https://storage.googleapis.com/mediapipe-models/object_detector/efficientdet_lite0/float16/1/efficientdet_lite0.tflite",
          delegate:"GPU"
        },
        scoreThreshold:0.3,
        runningMode:"VIDEO"
      });
      modelsReady.detector = true;
    }catch(e){
      console.error("ObjectDetector error", e);
      announce("Riconoscimento oggetti non disponibile. Guida oggetti limitata.");
    }

    try{
      poseLandmarker = await PoseLandmarker.createFromOptions(vision,{
        baseOptions:{
          modelAssetPath:"https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task",
          delegate:"GPU"
        },
        runningMode:"VIDEO",
        numPoses:1
      });
      modelsReady.pose = true;
    }catch(e){
      console.error("PoseLandmarker error", e);
      announce("Riconoscimento posa corpo non disponibile. Selfie avanzato limitato.");
    }

    try{
      faceLandmarker = await FaceLandmarker.createFromOptions(vision,{
        baseOptions:{
          modelAssetPath:"https://storage.googleapis.com/mediapipe-models/face_landmarker/face_landmarker/float16/1/face_landmarker.task",
          delegate:"GPU"
        },
        runningMode:"VIDEO",
        numFaces:1
      });
      modelsReady.face = true;
    }catch(e){
      console.error("FaceLandmarker error", e);
      announce("Riconoscimento volto non disponibile. Controlli testa limitati.");
    }

    if(modelsReady.detector && (modelsReady.pose || modelsReady.face)){
      announce("Riconoscimento oggetti e selfie attivo.");
    } else if(modelsReady.detector){
      announce("Solo riconoscimento oggetti attivo. Selfie avanzato disattivato.");
    } else if(modelsReady.pose || modelsReady.face){
      announce("Solo guida selfie attiva. Riconoscimento oggetti non disponibile.");
    } else {
      announce("Nessun modello di riconoscimento disponibile. Uso solo la fotocamera.");
    }
  }catch(e){
    console.error("Errore import MediaPipe", e);
    announce("Errore nel caricare i modelli di riconoscimento. Avrai solo funzioni base.");
  }

  isRunning = true;
  loop();
}

function loop(){
  if(!isRunning){
    requestAnimationFrame(loop);
    return;
  }
  if(video.readyState===4 && tempCtx){
    if(tempCanvas.width!==video.videoWidth){
      tempCanvas.width=video.videoWidth;
      tempCanvas.height=video.videoHeight;
      canvas.width=video.videoWidth;
      canvas.height=video.videoHeight;
    }
    tempCtx.drawImage(video,0,0,tempCanvas.width,tempCanvas.height);
    if(lightActive)processLight();
    if(colorActive)processColor();
    if(mode==='guiding')processGuidance();
  }
  requestAnimationFrame(loop);
}

window.openSettings=()=>{
  const ks = document.getElementById('key-screen');
  ks.classList.remove('hidden');
  ks.removeAttribute('aria-hidden');
  ks.removeAttribute('inert');
};
window.closeSettings=()=>{
  const ks = document.getElementById('key-screen');
  ks.classList.add('hidden');
  ks.setAttribute('aria-hidden','true');
  ks.setAttribute('inert','');
};
window.saveKey=()=>{
  GEMINI_KEY=document.getElementById('key-input').value.trim();
  localStorage.setItem('gemini_key',GEMINI_KEY);
  closeSettings();
  announce("Chiave Gemini salvata.");
};
</script>
</body>
</html>
